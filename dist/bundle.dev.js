/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var slcommon_src_Event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! slcommon/src/Event */ \"./node_modules/slcommon/src/Event.js\");\n/* harmony import */ var slcommon_src_Event__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(slcommon_src_Event__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var slcommon_src_EventManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slcommon/src/EventManager */ \"./node_modules/slcommon/src/EventManager.js\");\n/* harmony import */ var slcommon_src_EventManager__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(slcommon_src_EventManager__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var slcommon_src_EventNotifierMixin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! slcommon/src/EventNotifierMixin */ \"./node_modules/slcommon/src/EventNotifierMixin.js\");\n/* harmony import */ var slcommon_src_EventNotifierMixin__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(slcommon_src_EventNotifierMixin__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var slcommon_src_PriorityQueue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! slcommon/src/PriorityQueue */ \"./node_modules/slcommon/src/PriorityQueue.js\");\n/* harmony import */ var slcommon_src_PriorityQueue__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(slcommon_src_PriorityQueue__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var slcommon_src_Queue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! slcommon/src/Queue */ \"./node_modules/slcommon/src/Queue.js\");\n/* harmony import */ var slcommon_src_Queue__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(slcommon_src_Queue__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var slcommon_src_UniquePriorityQueue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! slcommon/src/UniquePriorityQueue */ \"./node_modules/slcommon/src/UniquePriorityQueue.js\");\n/* harmony import */ var slcommon_src_UniquePriorityQueue__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(slcommon_src_UniquePriorityQueue__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _src_BackgroundLayer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/BackgroundLayer */ \"./src/BackgroundLayer.js\");\n/* harmony import */ var _src_BackgroundLayer__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_src_BackgroundLayer__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _src_CanvasContextWrapper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/CanvasContextWrapper */ \"./src/CanvasContextWrapper.js\");\n/* harmony import */ var _src_CanvasContextWrapper__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_src_CanvasContextWrapper__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _src_EventType__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/EventType */ \"./src/EventType.js\");\n/* harmony import */ var _src_EventType__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_src_EventType__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _src_GfxElement__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/GfxElement */ \"./src/GfxElement.js\");\n/* harmony import */ var _src_GfxElement__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_src_GfxElement__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _src_GfxElementZIndexComparable__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/GfxElementZIndexComparable */ \"./src/GfxElementZIndexComparable.js\");\n/* harmony import */ var _src_GfxElementZIndexComparable__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_src_GfxElementZIndexComparable__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _src_GfxLayer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/GfxLayer */ \"./src/GfxLayer.js\");\n/* harmony import */ var _src_GfxLayer__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_src_GfxLayer__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var _src_ILayerFactory__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/ILayerFactory */ \"./src/ILayerFactory.js\");\n/* harmony import */ var _src_ILayerFactory__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_src_ILayerFactory__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var _src_ImageElement__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/ImageElement */ \"./src/ImageElement.js\");\n/* harmony import */ var _src_ImageElement__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_src_ImageElement__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var _src_ImageLoader__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/ImageLoader */ \"./src/ImageLoader.js\");\n/* harmony import */ var _src_ImageLoader__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_src_ImageLoader__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var _src_ImageRenderer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/ImageRenderer */ \"./src/ImageRenderer.js\");\n/* harmony import */ var _src_ImageRenderer__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_src_ImageRenderer__WEBPACK_IMPORTED_MODULE_15__);\n/* harmony import */ var _src_ImageSprite__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/ImageSprite */ \"./src/ImageSprite.js\");\n/* harmony import */ var _src_ImageSprite__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_src_ImageSprite__WEBPACK_IMPORTED_MODULE_16__);\n/* harmony import */ var _src_ImageSpriteFrame__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/ImageSpriteFrame */ \"./src/ImageSpriteFrame.js\");\n/* harmony import */ var _src_ImageSpriteFrame__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_src_ImageSpriteFrame__WEBPACK_IMPORTED_MODULE_17__);\n/* harmony import */ var _src_Layer__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/Layer */ \"./src/Layer.js\");\n/* harmony import */ var _src_Layer__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(_src_Layer__WEBPACK_IMPORTED_MODULE_18__);\n/* harmony import */ var _src_LayerFactory__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./src/LayerFactory */ \"./src/LayerFactory.js\");\n/* harmony import */ var _src_LayerFactory__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(_src_LayerFactory__WEBPACK_IMPORTED_MODULE_19__);\n/* harmony import */ var _src_MouseEvent__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./src/MouseEvent */ \"./src/MouseEvent.js\");\n/* harmony import */ var _src_MouseEvent__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(_src_MouseEvent__WEBPACK_IMPORTED_MODULE_20__);\n/* harmony import */ var _src_MoveOrder__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./src/MoveOrder */ \"./src/MoveOrder.js\");\n/* harmony import */ var _src_MoveOrder__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(_src_MoveOrder__WEBPACK_IMPORTED_MODULE_21__);\n/* harmony import */ var _src_Screen__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./src/Screen */ \"./src/Screen.js\");\n/* harmony import */ var _src_Screen__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__webpack_require__.n(_src_Screen__WEBPACK_IMPORTED_MODULE_22__);\n/* harmony import */ var _src_Sprite__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./src/Sprite */ \"./src/Sprite.js\");\n/* harmony import */ var _src_Sprite__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(_src_Sprite__WEBPACK_IMPORTED_MODULE_23__);\n/* harmony import */ var _src_SpriteAnimationFrame__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./src/SpriteAnimationFrame */ \"./src/SpriteAnimationFrame.js\");\n/* harmony import */ var _src_SpriteAnimationFrame__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(_src_SpriteAnimationFrame__WEBPACK_IMPORTED_MODULE_24__);\n/* harmony import */ var _src_Utils__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./src/Utils */ \"./src/Utils.js\");\n/* harmony import */ var _src_Utils__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/__webpack_require__.n(_src_Utils__WEBPACK_IMPORTED_MODULE_25__);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif (typeof self !== 'undefined' && self) {\n  self.SL = self.SL || {};\n  self.SL.Event = slcommon_src_Event__WEBPACK_IMPORTED_MODULE_0___default.a;\n  self.SL.EventManager = slcommon_src_EventManager__WEBPACK_IMPORTED_MODULE_1___default.a;\n  self.SL.EventNotifierMixin = slcommon_src_EventNotifierMixin__WEBPACK_IMPORTED_MODULE_2___default.a;\n  self.SL.PriorityQueue = slcommon_src_PriorityQueue__WEBPACK_IMPORTED_MODULE_3___default.a;\n  self.SL.Queue = slcommon_src_Queue__WEBPACK_IMPORTED_MODULE_4___default.a;\n  self.SL.UniquePriorityQueue = slcommon_src_UniquePriorityQueue__WEBPACK_IMPORTED_MODULE_5___default.a;\n  self.SL.BackgroundLayer = _src_BackgroundLayer__WEBPACK_IMPORTED_MODULE_6___default.a;\n  self.SL.CanvasContextWrapper = _src_CanvasContextWrapper__WEBPACK_IMPORTED_MODULE_7___default.a;\n  self.SL.EventType = _src_EventType__WEBPACK_IMPORTED_MODULE_8___default.a;\n  self.SL.GfxElement = _src_GfxElement__WEBPACK_IMPORTED_MODULE_9___default.a;\n  self.SL.GfxElementZIndexComparable = _src_GfxElementZIndexComparable__WEBPACK_IMPORTED_MODULE_10___default.a;\n  self.SL.GfxLayer = _src_GfxLayer__WEBPACK_IMPORTED_MODULE_11___default.a;\n  self.SL.ILayerFactory = _src_ILayerFactory__WEBPACK_IMPORTED_MODULE_12___default.a;\n  self.SL.ImageElement = _src_ImageElement__WEBPACK_IMPORTED_MODULE_13___default.a;\n  self.SL.ImageLoader = _src_ImageLoader__WEBPACK_IMPORTED_MODULE_14___default.a;\n  self.SL.ImageRenderer = _src_ImageRenderer__WEBPACK_IMPORTED_MODULE_15___default.a;\n  self.SL.ImageSprite = _src_ImageSprite__WEBPACK_IMPORTED_MODULE_16___default.a;\n  self.SL.ImageSpriteFrame = _src_ImageSpriteFrame__WEBPACK_IMPORTED_MODULE_17___default.a;\n  self.SL.Layer = _src_Layer__WEBPACK_IMPORTED_MODULE_18___default.a;\n  self.SL.LayerFactory = _src_LayerFactory__WEBPACK_IMPORTED_MODULE_19___default.a;\n  self.SL.MouseEvent = _src_MouseEvent__WEBPACK_IMPORTED_MODULE_20___default.a;\n  self.SL.MoveOrder = _src_MoveOrder__WEBPACK_IMPORTED_MODULE_21___default.a;\n  self.SL.Screen = _src_Screen__WEBPACK_IMPORTED_MODULE_22___default.a;\n  self.SL.Sprite = _src_Sprite__WEBPACK_IMPORTED_MODULE_23___default.a;\n  self.SL.SpriteAnimationFrame = _src_SpriteAnimationFrame__WEBPACK_IMPORTED_MODULE_24___default.a;\n  self.SL.Utils = _src_Utils__WEBPACK_IMPORTED_MODULE_25___default.a;\n}\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./node_modules/slcommon/src/Event.js":
/*!********************************************!*\
  !*** ./node_modules/slcommon/src/Event.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** Create an Event.\n* @class\n* @param {string} type The type of the event.\n* @param {Object} data Data for the event.  Determined by event emitter\n* @param {time} time Optional.  The time the event occurred. If not specified, uses Date.now()\n*/\nfunction Event(type, data, time) {\n  /** @member {string} */\n  this.type = type;\n  /** @member {Object} */\n\n  this.data = data;\n  /** @member {time} */\n\n  this.time = time || Date.now();\n}\n\n;\nmodule.exports = Event;\n\n//# sourceURL=webpack:///./node_modules/slcommon/src/Event.js?");

/***/ }),

/***/ "./node_modules/slcommon/src/EventManager.js":
/*!***************************************************!*\
  !*** ./node_modules/slcommon/src/EventManager.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var EventNotifierMixin = __webpack_require__(/*! ./EventNotifierMixin */ \"./node_modules/slcommon/src/EventNotifierMixin.js\");\n/**\n* Tracks event handlers and notifies them when events occur.\n* See {@link EventNotifierMixin} for full documentaiton.\n* @class\n* @augment {EventNotifierMixin}\n* @see EventNotifierMixin\n*/\n\n\nfunction EventManager() {\n  this.EventNotifierMixinInitializer({\n    eventListeners: []\n  });\n}\n\n;\nEventNotifierMixin.call(EventManager.prototype);\nmodule.exports = EventManager;\n\n//# sourceURL=webpack:///./node_modules/slcommon/src/EventManager.js?");

/***/ }),

/***/ "./node_modules/slcommon/src/EventNotifierMixin.js":
/*!*********************************************************!*\
  !*** ./node_modules/slcommon/src/EventNotifierMixin.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/slcommon/src/Utils.js\");\n\nvar Event = __webpack_require__(/*! ./Event */ \"./node_modules/slcommon/src/Event.js\");\n/** Add Event Notification functions to a class.\n* Tracks event handlers and notifies them when events occur.\n* Usage:\n* Call:\n*   EventNotifierMixin.call(MyClass.prototype);\n* And in your constructor, call initializer\"\n*   this.EventNotifierMixinInitializer();\n* Then you can add handlers:\n*   myClassInstance.on(\"myEvent1\", someHandlerCallback);\n* @class\n*/\n\n\nfunction EventNotifierMixin(props) {\n  props = props || {};\n  this._eventNotifierMixinId = EventNotifierMixin.id++;\n  this._eventNotifierMixinHandlerId = 0;\n  this._EventNotifierMixin_debug = props.EventNotifierMixin_debug || false;\n\n  this.EventNotifierMixinInitializer = function () {\n    this._eventListeners = {};\n  };\n  /** Add an event handler to the handler list.\n  * @param {EventType} eventType The type of the event.\n  * @param {Function} callback The handler to call when the specified event type occurs\n  * @param {string} id Optional. An Id to reference the handler by.\n  * @return {string} The id to reference the handler by.  For use in removing the handler.  If not explicitly provided a handler Id will be generated.\n  */\n\n\n  this.addEventHandler = function (eventType, callback, id) {\n    var handlerId = id || \"eventHandler_\" + this._eventNotifierMixinId + \".\" + this._eventNotifierMixinHandlerId;\n    this._eventNotifierMixinHandlerId++;\n\n    if (!this._eventListeners[eventType]) {\n      this.registerEventType(eventType);\n    }\n\n    this._eventListeners[eventType][handlerId] = callback;\n    return handlerId;\n  };\n  /** Register an event type.\n  * @private\n  */\n\n\n  this.registerEventType = function (eventType) {\n    this._eventListeners[eventType] = this._eventListeners[eventType] || {};\n  };\n  /** Alias for 'add'. Add an event handler to the handler list.\n  * @param {EventType} eventType The type of the event.\n  * @param {Function} callback The handler to call when the specified event type occurs\n  * @param {string} id Optional. An Id to reference the handler by.\n  */\n\n\n  this.on = this.addEventHandler;\n  /** Remove an event handler.\n  * @param {string} eventHandlerId The id of the handler to remove.\n  */\n\n  this.removeEventHandler = function (eventHandlerId) {\n    // delete\n    Object.keys(this._eventListeners).forEach(function (listenerKey) {\n      if (this._eventListeners[listenerKey][eventHandlerId]) delete this._eventListeners[listenerKey][eventHandlerId];\n    }.bind(this));\n  };\n  /** Clear all event handlers for a given event type.\n  * @param {EventType} eventType The type of the event.\n  */\n\n\n  this.clearEventHandlers = function (eventType) {\n    if (!this._eventListeners[eventType] && this._EventNotifierMixin_debug) {\n      console.log(\"Unknown event type:\" + eventType);\n    }\n\n    this._eventListeners[eventType] = {};\n  };\n  /** Notify event handlers when an event has occured.\n   * Overloads:\n   * <ul>\n   * <li>notify(anEvent);</li>\n   * <li>notify(eventType, someDate, eventTime);</li>\n   * </ul>\n  * @param {(Event|string)} event The event that occured, or the type of event.\n  * @param {Object} [data] The data associated with the event, if the first argument is the event type.\n  * @param {time} [time] The time of the event, if the first argument is the event type.\n  */\n\n\n  this.notify = function (eventOrEventType, data, time) {\n    var event = null;\n\n    if (eventOrEventType instanceof Event) {\n      event = eventOrEventType;\n    } else {\n      event = new Event(eventOrEventType, data, time);\n    }\n\n    if (!this._eventListeners[event.type]) {\n      if (this._EventNotifierMixin_debug) console.log(\"Unknown event type:\" + event.type);\n      return;\n    }\n\n    var keys = Object.keys(this._eventListeners[event.type]);\n\n    for (var i = 0; i < keys.length; i++) {\n      if (Utils.isFunction(this._eventListeners[event.type][keys[i]])) this._eventListeners[event.type][keys[i]](event);\n    }\n  };\n}\n\n;\nEventNotifierMixin.id = 0;\nmodule.exports = EventNotifierMixin;\n\n//# sourceURL=webpack:///./node_modules/slcommon/src/EventNotifierMixin.js?");

/***/ }),

/***/ "./node_modules/slcommon/src/PriorityQueue.js":
/*!****************************************************!*\
  !*** ./node_modules/slcommon/src/PriorityQueue.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @class Heap-based priority queue */\nfunction PriorityQueue() {\n  this._heapSize = 0;\n  this._a = [];\n  /** True: largest values will be at the front of the queue.\n  * False: smallest values will be at the front of the queue.\n  * False by default.\n  */\n\n  this.invertPriority = false;\n}\n\n;\n/** IComparable\n* @interface\n*/\n\nPriorityQueue.IComparable = function () {};\n/**\n* @param other {Object} The object to compare to this one.\n* @returns {int} -1: less than the other object; 0 equivalent to the other object; 1 greater than the other object.\n*/\n\n\nPriorityQueue.IComparable.prototype.compareTo = function (other) {\n  throw new Error('not implemented');\n};\n/**\n* @param other {Object} The object to compare to this one.\n* @returns {boolean} true if the objects are equivalent, false otherwise.\n*/\n\n\nPriorityQueue.IComparable.prototype.equals = function (other) {\n  throw new Error('not implemented');\n};\n/** Set whether this queue has inverted priority or not.\n* False: smallest values will be at the front of the queue.\n* True: largest values will be at the front of the queue.\n* False by default.\n* Setting the value will cause the queue to be reordered.\n* @param bool {boolean}\n*/\n\n\nPriorityQueue.prototype.setInvertPriority = function (bool) {\n  this.invertPriority = bool;\n  this.sort();\n};\n/** Sorts the queue.  */\n\n\nPriorityQueue.prototype.sort = function () {\n  this._buildMaxHeap();\n\n  for (var i = this._heapSize - 1; i >= 1; i--) {\n    this._swap(0, i);\n\n    this._maxHeapify(0, this._heapSize - (this._heapSize - i));\n  }\n};\n/** @private */\n\n\nPriorityQueue.prototype._maxHeapify = function (i, size, dir) {\n  var largest = 0;\n  var left = 2 * i + 1;\n  var right = 2 * i + 2;\n  if (dir === undefined) dir = this.invertPriority ? -1 : 1;\n\n  if (left < size && this._a[left].compareTo(this._a[i]) === dir) {\n    largest = left;\n  } else {\n    largest = i;\n  }\n\n  if (right < size && this._a[right].compareTo(this._a[largest]) === dir) {\n    largest = right;\n  }\n\n  if (largest != i) {\n    this._swap(i, largest);\n\n    this._maxHeapify(largest, size, dir);\n  }\n};\n/** @private */\n\n\nPriorityQueue.prototype._swap = function (i1, i2) {\n  var temp = this._a[i1];\n  this._a[i1] = this._a[i2];\n  this._a[i2] = temp;\n};\n/** @private */\n\n\nPriorityQueue.prototype._buildMaxHeap = function () {\n  for (var i = Math.floor((this._heapSize - 1) / 2); i >= 0; i--) {\n    this._maxHeapify(i, this._heapSize);\n  }\n};\n/** Removes and returns the item at the front of the queue\n* @return {Object} The item at the front of the queue.\n*/\n\n\nPriorityQueue.prototype.extractMax = function () {\n  if (this._heapSize < 1) {\n    return null;\n  }\n\n  var max = this._a[0];\n  this._a[0] = this._a[this._heapSize - 1];\n  this._heapSize--;\n\n  this._maxHeapify(0, this._heapSize, this.invertPriority ? 1 : -1);\n\n  return max;\n};\n/** Adds a new item to the queue.\n* @param element {PriorityQueue.IComparable} The item to be added to the queue.  Must implement Comparable.\n*/\n\n\nPriorityQueue.prototype.insert = function (element) {\n  var i = this._heapSize;\n  if (this._heapSize === this._a.length) this._a.push(element);else this._a[i] = element;\n  this._heapSize++;\n  this.increaseKey(i);\n};\n/** Used to update the queue when a element's priority has been increased.\n* Assumes the element has already been inserted.\n* Assumes you have updated the value on your own.\n* @param i {int} The index of the element to be updated.\n*/\n\n\nPriorityQueue.prototype.increaseKey = function (i) {\n  while (i > 0 && this._a[this._parent(i)].compareTo(this._a[i]) === (this.invertPriority ? -1 : 1)) {\n    this._swap(i, this._parent(i));\n\n    i = this._parent(i);\n  }\n};\n/** Used to update the queue when a element's priority has been decreased.\n* Assumes the element has already been inserted.\n* Assumes you have updated the value on your own.\n* @param i {int} The index of the element to be updated.\n*/\n\n\nPriorityQueue.prototype.decreaseKey = function (i) {\n  this._maxHeapify(i, this._heapSize, this.invertPriority ? 1 : -1);\n};\n/** Retrieve the element at a specified index.\n* Throws an error if i is out of bounds.\n* @param i {int} The index of the target element\n* @return {Object} The element found at the specified index.\n*/\n\n\nPriorityQueue.prototype.getByIndex = function (i) {\n  if (i > this._heapSize || i < 0) throw new Error(\"Index out of bounds: \" + i + \". (queue size:\" + this._heapSize + \")\");\n  return this._a[i];\n};\n/** Retrieve the first element that equals one specified.\n* Use this if you need to update the value/priority of an element in the queue.\n* @param i {IComparable} An element to search for.\n* @return {Object} The element if found; null otherwise.\n*/\n\n\nPriorityQueue.prototype.getByEquality = function (element) {\n  var idx = this.indexOf(element);\n  if (idx === -1) return null;\n  return this._a[idx];\n};\n/** Returns the size of the queue\n* @return {int} The size of the queue.\n*/\n\n\nPriorityQueue.prototype.size = function () {\n  return this._heapSize;\n};\n/** Returns whether the item exists in the queue.\n* @param element {PriorityQueue.IComparable} The element to search for.\n* @return {boolean} True if the element is in the queue; false otherwise.\n*/\n\n\nPriorityQueue.prototype.contains = function (element) {\n  for (var i = 0; i < this._heapSize; i++) {\n    if (element.equals(this._a[i])) return true;\n  }\n\n  return false;\n};\n/** Returns the index of the item if it exists in the queue.\n* @param element {PriorityQueue.IComparable} The element to search for.\n* @return {int} The index of the element in the queue; -1 if it does not exist.\n*/\n\n\nPriorityQueue.prototype.indexOf = function (element) {\n  for (var i = 0; i < this._heapSize; i++) {\n    if (element.equals(this._a[i])) return i;\n  }\n\n  return -1;\n};\n/**\n* @param element {PriorityQueue.IComparable} The element to be removed from the list.\n*/\n\n\nPriorityQueue.prototype.remove = function (element) {\n  if (this._heapSize < 1) {\n    return;\n  }\n\n  var idx = this.indexOf(element);\n  if (idx < 0) return;\n  this._a[idx] = this._a[this._heapSize - 1];\n  this._heapSize--;\n\n  this._maxHeapify(idx, this._heapSize, this.invertPriority ? 1 : -1);\n};\n/** Clear the queue. */\n\n\nPriorityQueue.prototype.clear = function () {\n  this._heapSize = 0;\n};\n/** @private */\n\n\nPriorityQueue.prototype._verifyHeap = function (i) {\n  if (i === undefined || i === null) i = 0;\n  if (i >= this._heapSize) return true;\n  var dir = this.invertPriority ? 1 : -1;\n  var left = 2 * i + 1;\n  var right = 2 * i + 2;\n  var isok = true;\n  if (left < this._heapSize && this._a[left].compareTo(this._a[i]) === dir) isok = false;\n  if (isok && right < this._heapSize && this._a[right].compareTo(this._a[i]) === dir) isok = false;\n\n  if (isok && left < this._heapSize) {\n    isok = this._verifyHeap(left);\n\n    if (isok && right < this._heapSize) {\n      isok = this._verifyHeap(right);\n    }\n  }\n\n  return isok;\n};\n/** @private */\n\n\nPriorityQueue.prototype._parent = function (i) {\n  return Math.floor((i - 1) / 2);\n};\n/** Removes and returns the item at the front of the queue\n* @method\n* @return {Object} The item at the front of the queue.\n*/\n\n\nPriorityQueue.prototype.pop = PriorityQueue.prototype.extractMax;\n/** Removes and returns the item at the front of the queue\n* @method\n* @return {Object} The item at the front of the queue.\n*/\n\nPriorityQueue.prototype.poll = PriorityQueue.prototype.extractMax;\n/** Adds a new item to the queue.\n* @method\n* @param element {PriorityQueue.IComparable} The item to be added to the queue.  Must implement Comparable.\n*/\n\nPriorityQueue.prototype.push = PriorityQueue.prototype.insert;\n/** Retrieve the element at the front of the queue.\n* @return {Object} The element at the front of the queue.\n*/\n\nPriorityQueue.prototype.peek = function () {\n  return this._heapSize < 1 ? null : this._a[0];\n};\n\nmodule.exports = PriorityQueue;\n\n//# sourceURL=webpack:///./node_modules/slcommon/src/PriorityQueue.js?");

/***/ }),

/***/ "./node_modules/slcommon/src/Queue.js":
/*!********************************************!*\
  !*** ./node_modules/slcommon/src/Queue.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/slcommon/src/Utils.js\");\n/** Simple Queue class\n* @constructor\n*/\n\n\nvar Queue = function Queue() {\n  this.head = null;\n  this.tail = null;\n  this._size = 0;\n};\n/** Adds a new item to the queue.\n* @param {Object} elem The item to be added to the queue.\n*/\n\n\nQueue.prototype.push = function (elem) {\n  var qelem = new QueueElement(elem, null);\n\n  if (this._size === 0) {\n    this.head = qelem;\n  } else {\n    this.tail.next = qelem;\n  }\n\n  this.tail = qelem;\n  this._size++;\n};\n/** Removes and returns the item at the front of the queue\n* @return {Object} The item at the front of the queue. Null if queue is empty.\n*/\n\n\nQueue.prototype.pop = function () {\n  var temp = this.head;\n\n  if (this.head !== null) {\n    this.head = this.head.next;\n    this._size--;\n  }\n\n  return temp === null ? null : temp.elem;\n};\n/** Clear the queue. */\n\n\nQueue.prototype.clear = function () {\n  this.head = null;\n  this.tail = null;\n  this._size = 0;\n};\n/** Retrieve an iterator for this queue.\n* @returns {Queue.QueueIterator}\n*/\n\n\nQueue.prototype.newIterator = function () {\n  return new Queue.QueueIterator(this.head);\n};\n/** Returns whether this queue contains the target object.\n* @returns {boolean}\n*/\n\n\nQueue.prototype.contains = function (target) {\n  var it = this.newIterator();\n  var element = null;\n\n  while ((element = it.getCurrent()) !== null) {\n    if (element === target || Utils.isFunction(element.equals) && element.equals(target)) return true;\n    it.next();\n  }\n\n  return false;\n};\n/** Check if the specified object exists in the queue; if so return the element, else return null.\n* @returns {Object}\n*/\n\n\nQueue.prototype.getByEquality = function (target) {\n  var it = this.newIterator();\n  var element = null;\n\n  while ((element = it.getCurrent()) !== null) {\n    if (element === target || Utils.isFunction(element.equals) && element.equals(target)) return element;\n    it.next();\n  }\n\n  return null;\n};\n/** Returns the size of the queue\n* @return {int} The size of the queue.\n*/\n\n\nQueue.prototype.size = function () {\n  return this._size;\n};\n/** The node class for the Queue.\n* @constructor\n* @param {Object} elem The object for this node.\n* @param {Object} next The next element in the queue.\n*/\n\n\nvar QueueElement = function QueueElement(elem, next) {\n  this.elem = elem;\n  this.next = next;\n};\n/** An iterator for a Queue.\n* @constructor\n* @param {QueueElement} head The head element of the Queue.\n*/\n\n\nQueue.QueueIterator = function (head) {\n  this._ptr = head;\n};\n/** Return the object for the current position in the queue.\n*/\n\n\nQueue.QueueIterator.prototype.getCurrent = function () {\n  return this._ptr === null ? null : this._ptr.elem;\n};\n/** Move the iterator to the next position in the queue. */\n\n\nQueue.QueueIterator.prototype.next = function () {\n  this._ptr = this._ptr === null ? null : this._ptr.next;\n};\n\nmodule.exports = Queue;\n\n//# sourceURL=webpack:///./node_modules/slcommon/src/Queue.js?");

/***/ }),

/***/ "./node_modules/slcommon/src/UniquePriorityQueue.js":
/*!**********************************************************!*\
  !*** ./node_modules/slcommon/src/UniquePriorityQueue.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var PriorityQueue = __webpack_require__(/*! ./PriorityQueue */ \"./node_modules/slcommon/src/PriorityQueue.js\");\n\nvar Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/slcommon/src/Utils.js\");\n/** Extension of PriorityQueue.\n* Enforces uniqueness of enqueued elements;\n* attempts made to enqueue an element that is\n* already in the queue will be ignored.\n*\n* Elements must implement getKey() method\n* @constructor\n*/\n\n\nfunction UniquePriorityQueue() {\n  PriorityQueue.call(this);\n  this._entryKeys = {};\n}\n\n;\nUniquePriorityQueue.prototype = new PriorityQueue();\nUniquePriorityQueue.prototype.constructor = UniquePriorityQueue;\n/** Adds a new item to the queue.\n* @param element {Object} The item to be added to the queue.  Must implement getKey() method.\n* @override\n*/\n\nUniquePriorityQueue.prototype.insert = function (element) {\n  if (this._entryKeys[element.getKey()]) return;\n  this._entryKeys[element.getKey()] = true;\n  PriorityQueue.prototype.insert.call(this, element);\n};\n/** Clear the queue. */\n\n\nUniquePriorityQueue.prototype.clear = function () {\n  this._entryKeys = {};\n  PriorityQueue.prototype.clear.call(this);\n};\n/** Removes and returns the item at the front of the queue\n* @return {Object} The item at the front of the queue.\n*/\n\n\nUniquePriorityQueue.prototype.extractMax = function () {\n  var element = PriorityQueue.prototype.extractMax.call(this);\n  if (element && Utils.isFunction(element.getKey) && this._entryKeys[element.getKey()]) delete this._entryKeys[element.getKey()];\n  return element;\n};\n/** Returns whether the item exists in the queue.\n* @param element {IComparable} The element to search for.\n* @return {boolean} True if the element is in the queue; false otherwise.\n*/\n\n\nUniquePriorityQueue.prototype.contains = function (element) {\n  return this._entryKeys[element.getKey()] === true;\n};\n/** Remove the specified element from the queue.\n* @param {Object} element\n*/\n\n\nUniquePriorityQueue.prototype.remove = function (element) {\n  PriorityQueue.prototype.remove.call(this, element);\n  if (this._entryKeys[element.getKey()]) delete this._entryKeys[element.getKey()];\n};\n/** Removes and returns the item at the front of the queue\n* @method\n* @return {Object} The item at the front of the queue.\n*/\n\n\nUniquePriorityQueue.prototype.pop = UniquePriorityQueue.prototype.extractMax;\n/** Removes and returns the item at the front of the queue\n* @method\n* @return {Object} The item at the front of the queue.\n*/\n\nUniquePriorityQueue.prototype.poll = UniquePriorityQueue.prototype.extractMax;\n/** Adds a new item to the queue.\n* @method\n* @param element {IComparable} The item to be added to the queue.  Must implement Comparable.\n*/\n\nUniquePriorityQueue.prototype.push = UniquePriorityQueue.prototype.insert;\nmodule.exports = UniquePriorityQueue;\n\n//# sourceURL=webpack:///./node_modules/slcommon/src/UniquePriorityQueue.js?");

/***/ }),

/***/ "./node_modules/slcommon/src/Utils.js":
/*!********************************************!*\
  !*** ./node_modules/slcommon/src/Utils.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @namespace */\nvar Utils = {};\n/** Check whether the argument is a function.\n* @param {Object} callback The object to check.\n* @returns {boolean} true if it is a function, false otherwise.\n*/\n\nUtils.isFunction = function (callback) {\n  return typeof callback === \"function\";\n};\n/** Search an array for a given value, using an equality function; returns the index\n* of the first occurence in the array, or -1 if not found.\n* This can be used to search for objects with a given property value.\n* @param {Array} array The array to search\n* @param {Object} value The target value to search for\n* @param {Function} equalityFunction The function to use to compare array elements to the target value.\n*   Should retruen true when elements are equal, false otherwise.\n* @returns {integer} The index of the located value, or -1 if not found\n*/\n\n\nUtils.linSearch = function (array, value, equalityFunction) {\n  for (var i = 0; i < array.length; i++) {\n    if (equalityFunction(array[i], value)) return i;\n  }\n\n  return -1;\n};\n/** Return whether the value is null or undefined.\n* @param {Any} value The value to test.\n* @returns {Boolean} True if the value is null or undefined; false otherwise.\n*/\n\n\nUtils.isNullOrUndefined = function (value) {\n  return value === null || value === undefined;\n};\n/** Return the degree value converted to radians.\n* @param {Number} degrees The value in degrees.\n* @returns {Number} The value in radians.\n*/\n\n\nUtils.degreesToRadians = function (degrees) {\n  return degrees / 180 * Math.PI;\n};\n/** Return whether two boxes collide.\n* @param {Number} x1 The X coordinate top left corner of box 1.\n* @param {Number} y1 The y coordinate top left corner of box 1.\n* @param {Number} width1 The width of box 1.\n* @param {Number} height1 The X height of box 1.\n* @param {Number} x2 The X coordinate top left corner of box 2.\n* @param {Number} y2 The y coordinate top left corner of box 2.\n* @param {Number} width2 The width of box 2.\n* @param {Number} height2 The X height of box 2.\n* @returns {Boolean} Returns true if boxes overlap,\n* false if they only touch or are disjoint.\n*/\n\n\nUtils.checkCollision = function (x1, y1, width1, height1, x2, y2, width2, height2) {\n  return x1 < x2 + width2 && x1 + width1 > x2 && y1 < y2 + height2 && y1 + height1 > y2;\n};\n/** Merge a collection of properties into an object.\n* Modifies the object.\n* @param {Object} properties The set of properties to merge into the object.\n* @param {Object} object The object to recieve the properties.\n*/\n\n\nUtils.mergeProperties = function (properties, object) {\n  var keys = Object.keys(properties);\n  if (!keys) return;\n  keys.forEach(function (key) {\n    object[key] = properties[key];\n  });\n};\n\nmodule.exports = Utils;\n\n//# sourceURL=webpack:///./node_modules/slcommon/src/Utils.js?");

/***/ }),

/***/ "./src/BackgroundLayer.js":
/*!********************************!*\
  !*** ./src/BackgroundLayer.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var GfxLayer = __webpack_require__(/*! ./GfxLayer */ \"./src/GfxLayer.js\");\n/** Background Graphics layer.<br />\n* Intended for backgrounds that don't change much; sprites are ok, but moving\n* elements will require marking the entire layer dirty for proper functionality.\n* Generally, the use of Screen.createLayer(\"BackgroundLayer\") is preferred over creating layer by hand.\n* @constructor\n* @augments GfxLayer\n* @param {Object} props The properties to create this layer with.\n* @param {Screen} props.screenContext The parent screen for this layer.\n* @param {CanvasContextWrapper} props.canvasContextWrapper The canvasContextWrapper. This layer will draw to the canvas' context, via wrapper's exposed methods.\n* @param {number} props.width The width of the layer.  Should match Screen.\n* @param {number} props.height The height of the layer.  Should match Screen.\n*/\n\n\nfunction BackgroundLayer(props) {\n  props = props || {};\n  GfxLayer.call(this, props);\n}\n\n;\nBackgroundLayer.prototype = new GfxLayer();\nBackgroundLayer.prototype.constructor = BackgroundLayer;\n/** Update the layer.\n* Calls update on each element.\n* DOES NOT PERFORM COLLISION CHECKING - USE ONLY WHEN ELEMENTS WON'T BE MOVING ON THEIR OWN.\n* @param {number} time The current time (milliseconds)\n* @param {number} diff The difference between the last time and the current time  (milliseconds)\n* @override\n*/\n\nBackgroundLayer.prototype.update = function (time, diff) {\n  var dirtyElement;\n  var i;\n\n  for (i = 0; i < this._elements.length; i++) {\n    // ensure all elements are redrawn if the layer is dirty\n    if (this.isDirty()) this._elements[i].setDirty(true);\n    dirtyElement = this._elements[i].update(time, diff);\n\n    if (dirtyElement) {\n      this._dirtyElements.push(this._elements[i].getZIndexComparable());\n    }\n  }\n};\n\nmodule.exports = BackgroundLayer;\n\n//# sourceURL=webpack:///./src/BackgroundLayer.js?");

/***/ }),

/***/ "./src/CanvasContextWrapper.js":
/*!*************************************!*\
  !*** ./src/CanvasContextWrapper.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * CanvasContextWrapper - wraps a CanvasRenderingContext2D to provide viewport capabilities.\n *\n * @class\n * @param  {Object} props\n * @param  {number} props.width The width; should match the width of the canvas element.\n * @param  {number} props.height The height; should match the height of the canvas element.\n * @param  {canvas} props.canvasContext          The canvasContext element.\n * @param  {number} [props.viewOriginX=0] X Coordinate of the viewport\n * @param  {number} [props.viewOriginY=0] y Coordinate of the viewport\n * @param  {bool} [props.imageSmoothingEnabled=false] Whether to use image smoothing.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D\n */\nfunction CanvasContextWrapper(props) {\n  this._width = props.width;\n  this._height = props.height;\n  this._canvasContext = props.canvasContext;\n  this._viewOriginX = props.viewOriginX || 0;\n  this._viewOriginY = props.viewOriginY || 0;\n  this.setImageSmoothingEnabled(props.imageSmoothingEnabled || false);\n}\n\n;\n/** Return the viewport X coordinate.\n * @return {number}\n */\n\nCanvasContextWrapper.prototype.getViewOriginX = function () {\n  return this._viewOriginX;\n};\n/** Return the viewport Y coordinate.\n * @return {number}\n */\n\n\nCanvasContextWrapper.prototype.getViewOriginY = function () {\n  return this._viewOriginY;\n};\n/** Set the X coordinate for the viewport.\n * @param  {number} viewOriginX\n */\n\n\nCanvasContextWrapper.prototype.setViewOriginX = function (viewOriginX) {\n  this._viewOriginX = viewOriginX;\n};\n/** Set the Y coordinate for the viewport.\n * @param  {number} viewOriginY\n */\n\n\nCanvasContextWrapper.prototype.setViewOriginY = function (viewOriginY) {\n  this._viewOriginY = viewOriginY;\n};\n/**\n * Get the canvas context for this wrapper.\n *\n * @return {CanvasRenderingContext2D}\n */\n\n\nCanvasContextWrapper.prototype.getCanvasContext = function () {\n  return this._canvasContext;\n};\n/** Check whether imageSmoothing is enabled for this canvasContext.\n * @return {bool}\n */\n\n\nCanvasContextWrapper.prototype.isImageSmoothingEnabled = function () {\n  return this._canvasContext.imageSmoothingEnabled;\n};\n/** Set whether imageSmoothing is enabled for this canvasContext.\n * @param {bool} imageSmoothingEnabled\n */\n\n\nCanvasContextWrapper.prototype.setImageSmoothingEnabled = function (imageSmoothingEnabled) {\n  this._canvasContext.imageSmoothingEnabled = imageSmoothingEnabled;\n};\n/** Clear a rectangular section of the canvas.\n* @param {number} x The x coordinate of the section.\n* @param {number} y The y coordinate of the section.\n* @param {number} width The width of the section.\n* @param {number} height The height of the section.\n*/\n\n\nCanvasContextWrapper.prototype.clearRect = function (x, y, width, height) {\n  if (this.isOutOfView(x, y, width, height)) return;\n\n  this._canvasContext.clearRect(x + this._viewOriginX, y + this._viewOriginY, width, height);\n};\n/** Clear the entire visible portion of the canvas.\n*/\n\n\nCanvasContextWrapper.prototype.clear = function () {\n  this._canvasContext.clearRect(0, 0, this._width, this._height);\n};\n/** Fill a rectangular section of the canvas.\n* Call CanvasContextWrapper#fillStyle to change color and style aspects of this operation.\n* @param {number} x The x coordinate of the section.\n* @param {number} y The y coordinate of the section.\n* @param {number} width The width of the section.\n* @param {number} height The height of the section.\n*/\n\n\nCanvasContextWrapper.prototype.fillRect = function (x, y, width, height) {\n  if (this.isOutOfView(x, y, width, height)) return;\n\n  this._canvasContext.fillRect(x + this._viewOriginX, y + this._viewOriginY, width, height);\n};\n/** Draw an image to the canvas.\n* @param {Image} image The source image to draw from.\n* @param {number} sx The x coordinate on the source image to start drawing from.\n* @param {number} sy The y coordinate on the source image to start drawing from.\n* @param {number} sWidth The width of the section of source image to draw.\n* @param {number} sHeight The height of the section of source image to draw.\n* @param {number} x The target x coordinate on the canvas to start drawing the image to.\n* @param {number} y The target y coordinate on the canvas to start drawing the image to.\n* @param {number} width The width of the target section on the canvas to draw to.\n* @param {number} height The height of the target section on the canvas to draw to.\n*/\n\n\nCanvasContextWrapper.prototype.drawImage = function (image, sx, sy, sWidth, sHeight, x, y, width, height) {\n  if (this.isOutOfView(x, y, width, height)) return;\n\n  this._canvasContext.drawImage(image, sx, sy, sWidth, sHeight, x + this._viewOriginX, y + this._viewOriginY, width, height);\n};\n/** Draw an image to the canvas, when the canvas has been rotated or flipped.\n* @param {Image} image The source image to draw from.\n* @param {number} sx The x coordinate on the source image to start drawing from.\n* @param {number} sy The y coordinate on the source image to start drawing from.\n* @param {number} sWidth The width of the section of source image to draw.\n* @param {number} sHeight The height of the section of source image to draw.\n* @param {number} x The target x coordinate on the canvas to start drawing the image to.\n* @param {number} y The target y coordinate on the canvas to start drawing the image to.\n* @param {number} width The width of the target section on the canvas to draw to.\n* @param {number} height The height of the target section on the canvas to draw to.\n*/\n\n\nCanvasContextWrapper.prototype.drawImageWithTranslation = function (image, sx, sy, sWidth, sHeight, x, y, width, height) {\n  this._canvasContext.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n};\n/** Fill a rectangular section of the canvas, when the canvas has been flipped or rotated.\n* Call CanvasContextWrapper#fillStyle to change color and style aspects of this operation.\n* @param {number} x The x coordinate of the section.\n* @param {number} y The y coordinate of the section.\n* @param {number} width The width of the section.\n* @param {number} height The height of the section.\n*/\n\n\nCanvasContextWrapper.prototype.fillRectWithTranslation = function (x, y, width, height) {\n  this._canvasContext.fillRect(x, y, width, height);\n};\n/** Save the current state of the canvas context.  Restore it with CanvasContextWrapper#restore */\n\n\nCanvasContextWrapper.prototype.save = function () {\n  this._canvasContext.save();\n};\n/** Restore a saved canvas context state */\n\n\nCanvasContextWrapper.prototype.restore = function () {\n  this._canvasContext.restore();\n};\n/** Move the canvas context to the specified coordinates.\n* @param {number} x The x coordinate.\n* @param {number} y The y coordinate.\n*/\n\n\nCanvasContextWrapper.prototype.translate = function (x, y) {\n  this._canvasContext.translate(x + this._viewOriginX, y + this._viewOriginY);\n};\n/** Scale the canvas context by a percentage.\n* @param {number} x The percent to horizonatally scale the context. e.g., 2 = double the canvas context width.\n* @param {number} y The percent to vertically  scale the context. e.g., 0.5 = half the canvas context height.\n*/\n\n\nCanvasContextWrapper.prototype.scale = function (x, y) {\n  this._canvasContext.scale(x, y);\n};\n/** Rotate the canvas.\n* @param {number} rotation The amount to rotate the canvas by, in radians.\n*/\n\n\nCanvasContextWrapper.prototype.rotate = function (rotation) {\n  this._canvasContext.rotate(rotation);\n};\n/** Check if a specified section of the context is outside the visible portion of the canvas.\n* @param {number} x The x coordinate of the section.\n* @param {number} y The y coordinate of the section.\n* @param {number} width The width coordinate of the section.\n* @param {number} height The height coordinate of the section.\n*/\n\n\nCanvasContextWrapper.prototype.isOutOfView = function (x, y, width, height) {\n  return this._viewOriginX + x + width < 0 || this._viewOriginX + x > this._width || this._viewOriginY + y + height < 0 || this._viewOriginY + y > this._height;\n};\n/** Set the fill style for the canvas context\n* @param {string} style The style to apply for filling.\n* For options @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle\n*/\n\n\nCanvasContextWrapper.prototype.setFillStyle = function (style) {\n  this._canvasContext.fillStyle = style;\n};\n/** Begin a drawing path.\n* @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/beginPath\n*/\n\n\nCanvasContextWrapper.prototype.beginPath = function () {\n  this._canvasContext.beginPath();\n};\n/**  Begin a new sub-path at the point specified by the given coordinates\n* @param {number} x The x coordinate.\n* @param {number} y The y coordinate.\n* @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/moveTo\n*/\n\n\nCanvasContextWrapper.prototype.moveTo = function (x, y) {\n  this._canvasContext.moveTo(this._viewOriginX + x, this._viewOriginY + y);\n};\n/** Add a line to current path from the current location to the specified location.\n* @param {number} x The x coordinate to draw the line to.\n* @param {number} y The y coordinate to draw the line to.\n* @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineTo\n*/\n\n\nCanvasContextWrapper.prototype.lineTo = function (x, y) {\n  this._canvasContext.lineTo(this._viewOriginX + x, this._viewOriginY + y);\n};\n/** Close the current path\n* @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/closePath\n*/\n\n\nCanvasContextWrapper.prototype.closePath = function () {\n  this._canvasContext.closePath();\n};\n/** Strokes the current path\n* @param https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/stroke\n*/\n\n\nCanvasContextWrapper.prototype.stroke = function () {\n  this._canvasContext.stroke();\n};\n/** Add a rectangle to the current path.\n* @param {number} x The x coordinate of the rectangle.\n* @param {number} y The y coordinate of the rectangle.\n* @param {number} width The width of the rectangle.\n* @param {number} height The height of the rectangle.\n* @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/rect\n*/\n\n\nCanvasContextWrapper.prototype.rect = function (x, y, width, height) {\n  this._canvasContext.rect(x, y, width, height);\n};\n/** Set the width of lines for path drawing.\n* @param {number} width The width\n*/\n\n\nCanvasContextWrapper.prototype.setLineWidth = function (width) {\n  this._canvasContext.lineWidth = width;\n};\n/** Set stroke style for path\n* @param {string} strokeStyle\n* @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle\n*/\n\n\nCanvasContextWrapper.prototype.setStrokeStyle = function (strokeStyle) {\n  this._canvasContext.strokeStyle = strokeStyle;\n};\n/** Draws a stroked rectangle.\n* @param {number} x The x coordinate of the rectangle.\n* @param {number} y The y coordinate of the rectangle.\n* @param {number} width The width of the rectangle.\n* @param {number} height The height of the rectangle.\nhttps://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeRect\n*/\n\n\nCanvasContextWrapper.prototype.strokeRect = function (x, y, width, height) {\n  this._canvasContext.strokeRect(x, y, width, height);\n};\n/** Fills a given text at the given (x,y) position. Optionally with a maximum width to draw.\n* @param {string} text\n* @param {number} x\n* @param {number} y\n* @param {number} maxWidth\n*/\n\n\nCanvasContextWrapper.prototype.fillText = function (text, x, y, maxWidth) {\n  this._canvasContext.fillText(text, x, y, maxWidth);\n};\n/** Strokes a given text at the given (x,y) position. Optionally with a maximum width to draw.\n* @param {string} text\n* @param {number} x\n* @param {number} y\n* @param {number} maxWidth\n*/\n\n\nCanvasContextWrapper.prototype.strokeText = function (text, x, y, maxWidth) {\n  this._canvasContext.strokeText(text, x, y, maxWidth);\n};\n/** Set the font style for the canvas.\n* @param {string} val Style in format of '12px Sans'; the font size and the font families, separated with spaces.\n*/\n\n\nCanvasContextWrapper.prototype.setFontStyle = function (val) {\n  this._canvasContext.font = val;\n};\n/** Text alignment setting. Possible values: start, end, left, right or center. The default value is start.\n* @param {string} val\n*/\n\n\nCanvasContextWrapper.prototype.setTextAlign = function (val) {\n  this._canvasContext.textAlign = val;\n};\n/**\n* Baseline alignment setting. Possible values: top, hanging, middle, alphabetic, ideographic, bottom. The default value is alphabetic.\n* @param {string} val\n*/\n\n\nCanvasContextWrapper.prototype.setTextBaseline = function (val) {\n  this._canvasContext.textBaseline = val;\n};\n/**\n* Set directionality for text. Possible values: ltr, rtl, inherit. The default value is inherit.\n* @param {string} val\n*/\n\n\nCanvasContextWrapper.prototype.setTextDirection = function (val) {\n  this._canvasContext.direction = val;\n};\n\nmodule.exports = CanvasContextWrapper;\n\n//# sourceURL=webpack:///./src/CanvasContextWrapper.js?");

/***/ }),

/***/ "./src/EventType.js":
/*!**************************!*\
  !*** ./src/EventType.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** Event types enumeration.\n* @enum {string}\n* @namespace\n*/\nvar EventType = {};\n/** Fired when the screen is paused. */\n\nEventType.SCREEN_PAUSED = \"SCREEN_PAUSED\";\n/** Fired when the screen is unpaused. */\n\nEventType.SCREEN_RESUMED = \"SCREEN_RESUMED\";\n/** Fired before the next frame is rendered. */\n\nEventType.BEFORE_RENDER = \"BEFORE_RENDER\";\n/** Fired after the last frame render completes */\n\nEventType.AFTER_RENDER = \"AFTER_RENDER\";\n/** Fired when the mouse moves inside the bounds of the Screen. */\n\nEventType.MOUSE_MOVE = \"MOUSE_MOVE\";\n/** Fired when the mouse button is released inside the bounds of the Screen. */\n\nEventType.MOUSE_UP = \"MOUSE_UP\";\n/** Fired when the mouse button is pressed inside the bounds of the Screen. */\n\nEventType.MOUSE_DOWN = \"MOUSE_DOWN\";\n/** A GfxElement moved.\n* @see ElementEvent\n*/\n\nEventType.ELEMENT_MOVED = \"ELEMENT_MOVED\";\n/** A GfxElement started moving.\n* @see ElementEvent\n*/\n\nEventType.ELEMENT_STARTED_MOVING = \"ELEMENT_STARTED_MOVING\";\n/** A GfxElement stopped moving.\n* @see ElementEvent\n*/\n\nEventType.ELEMENT_STOPPED_MOVING = \"ELEMENT_STOPPED_MOVING\";\n/** A GfxElement stopped moving.\n* @see ElementCollidesWithElementEvent\n*/\n\nEventType.ELEMENT_COLLISION = \"ELEMENT_COLLISION\";\n/** The mouse entered an element's collison box.\n* @see ElementMouseEvent\n*/\n\nEventType.MOUSE_ENTER_ELEMENT = \"MOUSE_ENTER_ELEMENT\";\n/** The mouse left an element's collison box.\n* @see ElementMouseEvent\n*/\n\nEventType.MOUSE_EXIT_ELEMENT = \"MOUSE_EXIT_ELEMENT\";\n/** The mouse moved within an element's collison box.\n* @see ElementMouseEvent\n*/\n\nEventType.MOUSE_MOVE_OVER_ELEMENT = \"MOUSE_MOVE_OVER_ELEMENT\";\n/** The mouse button was pressed within an element's collison box.\n* @see ElementMouseEvent\n*/\n\nEventType.MOUSE_DOWN_ON_ELEMENT = \"MOUSE_DOWN_ON_ELEMENT\";\n/** The mouse button was released within an element's collison box.\n* @see ElementMouseEvent\n*/\n\nEventType.MOUSE_UP_ON_ELEMENT = \"MOUSE_UP_ON_ELEMENT\";\n/** An Element hit the left edge of a layer.\n* @see ElementCollidesWithEdgeEvent\n*/\n\nEventType.ELEMENT_HIT_LEFT_EDGE = \"ELEMENT_HIT_LEFT_EDGE\";\n/** An Element hit the right edge of a layer.\n* @see ElementCollidesWithEdgeEvent\n*/\n\nEventType.ELEMENT_HIT_RIGHT_EDGE = \"ELEMENT_HIT_RIGHT_EDGE\";\n/** An Element hit the top edge of a layer.\n* @see ElementCollidesWithEdgeEvent\n*/\n\nEventType.ELEMENT_HIT_TOP_EDGE = \"ELEMENT_HIT_TOP_EDGE\";\n/** An Element hit the bottom edge of a layer.\n* @see ElementCollidesWithEdgeEvent\n*/\n\nEventType.ELEMENT_HIT_BOTTOM_EDGE = \"ELEMENT_HIT_BOTTOM_EDGE\";\n/** A sprite completed its animation */\n\nEventType.SPRITE_ANIMATION_DONE = \"SPRITE_ANIMATION_DONE\";\n/** Intended for use as one-time events; handlers will be cleared by the screen after each frame. */\n\nEventType.NEXT_FRAME_BEGIN = \"NEXT_FRAME_BEGIN\";\n/** Intended for use as one-time events; handlers will be cleared by the screen after each frame. */\n\nEventType.NEXT_FRAME_END = \"NEXT_FRAME_END\";\nmodule.exports = EventType;\n/**\n * A Mouse Event on a GfxElement.\n * @typedef {Object} ElementMouseEvent\n * @property {string} type EventType\n * @property {Object} data The data provided by the event emitter.\n * @property {number} data.x The functional x coordinate of the mouse, incorporating the scale of canvas context wrapper view origin.\n * @property {number} data.y The functional y coordinate of the mouse, incorporating the scale of canvas context wrapper view origin.\n * @property {number} data.viewOriginAdjustedX The x coordinate of the mouse, relative to the view origin of the canvas context wrapper.\n * @property {number} data.viewOriginAdjustedY The y coordinate of the mouse, relative to the view origin of the canvas context wrapper.\n * @property {number} data.rawX The raw, unscaled x coordinate of the mouse, relative to the canvas.\n * @property {number} data.rawY The raw, unscaled y coordinate of the mouse, relative to the canvas.\n * @property {GfxElement} data.element The element that the mouse interacted with.\n * @property {number} time The time the event was fired.\n */\n\n/**\n * GfxElement Event.\n * @typedef {Object} ElementEvent\n * @property {string} type EventType\n * @property {Object} data The data provided by the event emitter.\n * @property {GfxElement} data.element The element where the event occurred.\n * @property {number} time The time the event was fired.\n */\n\n/**\n * GfxElement collides with another.\n * @typedef {Object} ElementCollidesWithElementEvent\n * @property {string} type EventType\n * @property {Object} data The data provided by the event emitter.\n * @property {GfxElement} data.element1 The first element in the collision.\n * @property {GfxElement} data.element2 The first element in the collision.\n * @property {number} time The time the event was fired.\n */\n\n/**\n* GfxElement hit the edge of a layer.\n* @typedef {Object} ElementCollidesWithEdgeEvent\n* @property {string} type EventType; indicates which edge was hit.\n* @property {Object} data The data provided by the event emitter.\n* @property {GfxLayer} data.layer The layer where the event occured.\n* @property {GfxElement} data.element The element that hit the edge.\n* @property {number} time The time the event was fired.\n*/\n\n/**\n * A Mouse Event on the screen.\n * @typedef {Object} ScreenMouseEvent\n * @property {string} type EventType\n * @property {Object} data The data provided by the event emitter.\n * @property {number} data.x The functional x coordinate of the mouse, incorporating the scale of canvas context wrapper view origin.\n * @property {number} data.y The functional y coordinate of the mouse, incorporating the scale of canvas context wrapper view origin.\n * @property {number} data.viewOriginAdjustedX The x coordinate of the mouse, relative to the view origin of the canvas context wrapper.\n * @property {number} data.viewOriginAdjustedY The y coordinate of the mouse, relative to the view origin of the canvas context wrapper.\n * @property {number} data.rawX The raw, unscaled x coordinate of the mouse, relative to the canvas.\n * @property {number} data.rawY The raw, unscaled y coordinate of the mouse, relative to the canvas.\n * @property {event} data.baseEvent The original mouse event in the browser.  Only provided on mouse up/down events.\n * @property {number} time The time the event was fired.\n */\n\n/**\n* Event that is triggered immediately before or after the screen's render cycle.\n* @typedef {Object} ScreenRenderEvent\n* @property {string} type EventType\n* @property {Object} data The data provided by the event emitter.\n* @property {number} data.diff The amount of time passed between this and the last render cycle.\n* @property {number} time The time the event was fired.\n*/\n\n//# sourceURL=webpack:///./src/EventType.js?");

/***/ }),

/***/ "./src/GfxElement.js":
/*!***************************!*\
  !*** ./src/GfxElement.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Queue = __webpack_require__(/*! slcommon/src/Queue */ \"./node_modules/slcommon/src/Queue.js\");\n\nvar GfxElementZIndexComparable = __webpack_require__(/*! ./GfxElementZIndexComparable */ \"./src/GfxElementZIndexComparable.js\");\n\nvar EventNotifierMixin = __webpack_require__(/*! slcommon/src/EventNotifierMixin */ \"./node_modules/slcommon/src/EventNotifierMixin.js\");\n\nvar Utils = __webpack_require__(/*! ./Utils */ \"./src/Utils.js\");\n\nvar Event = __webpack_require__(/*! slcommon/src/Event */ \"./node_modules/slcommon/src/Event.js\");\n\nvar EventType = __webpack_require__(/*! ./EventType */ \"./src/EventType.js\");\n\nvar MoveOrder = __webpack_require__(/*! ./MoveOrder */ \"./src/MoveOrder.js\");\n\nvar MouseEvent = __webpack_require__(/*! ./MouseEvent */ \"./src/MouseEvent.js\");\n/** <p>Graphics element base class.</p>\n* <p>Current Implementations:\n* <ul>\n*   <li>{@link ImageElement}</li>\n*   <li>{@link Sprite}\n*     <ul>\n*       <li>{@link ImageSprite}</li>\n*     </ul>\n*   </li>\n* </ul></p>\n* <p>GfxElements support two types of movement: moveTo() instructions and movementRates.\n* The former, moveTo() will send an element toward a specified set of coordinates, scheduled to arrive after a\n* specified duration.  The latter, movementRates, will start an element moving at a given rate and continue until stopped.\n* See moveTo() and setMoveRates() for more details.</p>\n* <p> GfxElements emit a number of events.\n* In most cases, the event data will include an 'element' property that refers to the element.  The only exception is ELEMENT_COLLISION;\n* this will have element1 and element2 properties, where element1 is the element on which collidesWith() was called, and element2 was the element passed to the method.</p>\n* <p>In addition to the element property, the mouse events will also include x,y properties in the data, corresponding to the coordinates of the event. </p>\n*\n* <p>Event listeners can be attached to individual elements, or at the screen level.  Refer to documentation on the \"on\" and \"notify\" methods.</p>\n*\n* @constructor\n* @param {Object} props Properties for this GfxElement.\n* @param {Screen} props.screenContext The target screen.\n* @param {int} [props.scaleX=1] Horizontal scale of this element.  Independent of screen scale.\n* @param {int} [props.scaleY=1] Vertical scale of this element.  Independent of screen scale.\n* @param {boolean} [props.hidden=false] Whether to hide this element.\n* @param {number} [props.x=0] The X coordinate for this element.\n* @param {number} [props.y=0] The Y coordinate for this element.\n* @param {number} props.width The width of this element.\n* @param {number} props.height The height this element.\n* @param {number} [props.rotation=0] The amount of rotation to apply to the element, in radians.  Applied on top of base rotation.\n* @param {number} [props.baseRotation=0] The amount of base rotation to apply to the element, in radians. Usually used to apply an initial, unchanging rotation to the element.  Useful for correcting orientation of images.\n* @param {boolean} [props.horizontalFlip=false] Whether to flip the element horizontally.\n* @param {boolean} [props.verticalFlip=false] Whether to flip the element vertically.\n* @param {number} [props.zIndex=-1] The z-index; elements with higher zIndex values will be drawn later than those with lower values (drawn on top of those with lower values).\n*/\n\n\nfunction GfxElement(props) {\n  props = props || {};\n  this._id = GfxElement.id++;\n  this._screenContext = props.screenContext;\n  this._scaleX = props.scaleX || 1;\n  this._scaleY = props.scaleY || 1;\n  this._currentMove = null;\n  this._moveQueue = new Queue();\n  this._xMoveRate = 0;\n  this._xMoveFractionalAccumulator = 0;\n  this._yMoveRate = 0;\n  this._yMoveFractionalAccumulator = 0;\n  this._dirty = true;\n  this._hasCollision = false;\n  this._hadCollisionPreviousFrame = false;\n  this._hidden = props.hidden || false;\n  this._x = props.x || 0;\n  this._y = props.y || 0;\n  this._lastX = 0;\n  this._lastY = 0;\n  this._mouseIsOver = false;\n  this._zIndex = props.zIndex || -1;\n  this._zIndexComparable = new GfxElementZIndexComparable(this);\n  this._width = props.width;\n  this._height = props.height;\n  this._rotation = props.rotation || null;\n  this._baseRotation = props.baseRotation || null;\n  this._wasRotated = props.rotation ? true : false;\n  this._scaledDiagonalSize = 0; // only needed for determining collision box when rotated\n\n  this._rotatedScaledX = 0;\n  this._rotatedScaledY = 0;\n  this._lastCollisionBoxX = this._x;\n  this._lastCollisionBoxY = this._y;\n  this._lastCollisionBoxWidth = 0;\n  this._lastCollisionBoxHeight = 0;\n  this._horizontalFlip = props.horizontalFlip || false;\n  this._verticalFlip = props.verticalFlip || false;\n  this._flashDoneCallback = null;\n  this._isFlashing = false;\n  this._flashStartTime = -1;\n  this._flashDuration = 0;\n  this._flashHidden = false;\n  this._flashElapsed = 0;\n  this._flashInterval = 0;\n  this._nudgeDoneCallback = null;\n  this._isProcessingNudge = false;\n  this._shakeDoneCallback = null;\n  this._isProcessingShake = false;\n\n  this._recalculateRotatedCollisionBox();\n\n  this.EventNotifierMixinInitializer();\n}\n\n;\nEventNotifierMixin.call(GfxElement.prototype);\nGfxElement.prototype._baseNotify = GfxElement.prototype.notify;\n/*\n* Canvas AntiAliasing tends to draw beyond the actual pixel bounds of an image, or\n* shape.  This helps slgfx correct for this behavior.\n* ALSO IMPORTANT - using fractions here tends to reduce performance (!?!)\n* on some basic benchmarks... so avoid them if possible.\n* (Benchmark on Firefox 57.0.2)\n*/\n\nGfxElement.AntiAliasCorrection = {\n  coordinateOffset: -1,\n  sizeAdjustment: 2\n};\n/** Notify event handlers when an event has occured.\n* @param {Event} event The event that occured\n*/\n\nGfxElement.prototype.notify = function (event) {\n  this._baseNotify(event);\n\n  this.getScreenContext().notify(event);\n};\n/** @private */\n\n\nGfxElement.id = 0;\n/** Return the unique id of this element.\n* @return {int} This element's unique id.\n*/\n\nGfxElement.prototype.getId = function () {\n  return this._id;\n};\n/** Return whether this element is dirty.\n* @return {boolean}\n*/\n\n\nGfxElement.prototype.isDirty = function () {\n  return this._dirty || this._hasCollision || this._hadCollisionPreviousFrame;\n};\n/**\n* Set whether element is dirty.  If dirty, the element will be cleared and redrawn during the next render phase.\n* @param {boolean} dirty\n*/\n\n\nGfxElement.prototype.setDirty = function (dirty) {\n  this._dirty = dirty;\n};\n/** Return whether this element is hidden.\n* @return {boolean}\n*/\n\n\nGfxElement.prototype.isHidden = function () {\n  return this._hidden;\n};\n/**\n* Set whether element is hidden.\n* @param {boolean} hidden\n*/\n\n\nGfxElement.prototype.setHidden = function (hidden) {\n  this._hidden = hidden;\n};\n/** Return whether this element had a collision during the most recent update phase.\n* @return {boolean}\n*/\n\n\nGfxElement.prototype.hasCollision = function () {\n  return this._hasCollision;\n};\n/**\n* Set whether the element has a collision. If a collision has occurred the element will be cleared and redrawn during the next render phase.\n* @param {boolean} hidden\n*/\n\n\nGfxElement.prototype.setHasCollision = function (hasCollision) {\n  this._hasCollision = hasCollision;\n};\n/**\n* Return this element's zIndex.\n* @return {number}\n*/\n\n\nGfxElement.prototype.getZIndex = function () {\n  return this._zIndex;\n};\n/**\n* Set this element's zIndex. Elements with higher zIndex values will be drawn later than those with lower values (drawn on top of those with lower values).\n* @param {number} zIndex\n*/\n\n\nGfxElement.prototype.setZIndex = function (zIndex) {\n  this._zIndex = zIndex;\n  this.setDirty(true);\n};\n/** Return this element's zindeComparable.\n* Used by parent layer to determine rendering order.\n* @return {GfxElementZIndexComparable}\n*/\n\n\nGfxElement.prototype.getZIndexComparable = function () {\n  return this._zIndexComparable;\n};\n/**\n* Return the parent Screen for this element.\n* @return {Screen}\n*/\n\n\nGfxElement.prototype.getScreenContext = function () {\n  return this._screenContext;\n};\n/**\n* Return the horizontal scale of this element's parent screen.\n* @return {int}\n*/\n\n\nGfxElement.prototype.getScreenScaleX = function () {\n  return this.getScreenContext().getScaleX();\n};\n/**\n* Return the vertical scale of this element's parent screen.\n* @return {int}\n*/\n\n\nGfxElement.prototype.getScreenScaleY = function () {\n  return this.getScreenContext().getScaleY();\n};\n/**\n* Return the total horizontal scale for this element (screen scale * element scale).\n* @return {int}\n*/\n\n\nGfxElement.prototype.getTotalScaleX = function () {\n  return this.getElementScaleX() * this.getScreenContext().getScaleX();\n};\n/**\n* Return the total vertical scale for this element (screen scale * element scale).\n* @return {int}\n*/\n\n\nGfxElement.prototype.getTotalScaleY = function () {\n  return this.getElementScaleY() * this.getScreenContext().getScaleY();\n};\n/**\n* Return the horizontal scale of this element.\n* @return {int}\n*/\n\n\nGfxElement.prototype.getElementScaleX = function () {\n  return this._scaleX;\n};\n/**\n* Return the vertical scale of this element.\n* @return {int}\n*/\n\n\nGfxElement.prototype.getElementScaleY = function () {\n  return this._scaleY;\n};\n/**\n* Set the horizontal scale of this element.\n* @param {int} scaleX\n*/\n\n\nGfxElement.prototype.setElementScaleX = function (scaleX) {\n  this._scaleX = scaleX;\n};\n/**\n* Set the vertical scale of this element.\n* @param {int} scaleY\n*/\n\n\nGfxElement.prototype.setElementScaleY = function (scaleY) {\n  this._scaleY = scaleY;\n};\n/**\n* Get the x coordinate of this element.\n* @return {number}\n*/\n\n\nGfxElement.prototype.getX = function () {\n  return this._x;\n};\n/**\n* Get the screen x coordinate of this element.\n* @return {number}\n*/\n\n\nGfxElement.prototype.getScaledX = function () {\n  return this.getX() * this.getScreenScaleX();\n};\n/**\n* Get the y coordinate of this element.\n* @return {number}\n*/\n\n\nGfxElement.prototype.getY = function () {\n  return this._y;\n};\n/**\n* Get the screen x coordinate of this element.\n* @return {number}\n*/\n\n\nGfxElement.prototype.getScaledY = function () {\n  return this.getY() * this.getScreenScaleY();\n};\n/**\n* Set the x coordinate of this element.\n* @param {number} x\n*/\n\n\nGfxElement.prototype.setX = function (x) {\n  if (x !== this._x) this.setDirty(true);\n  this._x = x;\n};\n/**\n* Set the y coordinate of this element.\n* @param {number} y\n*/\n\n\nGfxElement.prototype.setY = function (y) {\n  if (y !== this._y) this.setDirty(true);\n  this._y = y;\n};\n/** @private */\n\n\nGfxElement.prototype.getLastX = function () {\n  return this._lastX;\n};\n/** @private */\n\n\nGfxElement.prototype.getLastY = function () {\n  return this._lastY;\n};\n/** @private */\n\n\nGfxElement.prototype.getLastWidth = function () {\n  return this.getWidth();\n};\n/** @private */\n\n\nGfxElement.prototype.getLastHeight = function () {\n  return this.getHeight();\n};\n/** @private */\n\n\nGfxElement.prototype.setLastX = function (x) {\n  this._lastX = x;\n};\n/** @private */\n\n\nGfxElement.prototype.setLastY = function (y) {\n  this._lastY = y;\n};\n/**\n* Return whether the mouse is over this element.\n* @return {boolean}\n*/\n\n\nGfxElement.prototype.isMouseOver = function () {\n  return this._mouseIsOver;\n};\n/**\n* Return this element's width.\n* @abstract\n* @return {number}\n*/\n\n\nGfxElement.prototype.getWidth = function () {\n  return this._width;\n};\n/**\n* Return this element's width, incorporating screen and element-local scaling.\n* @return {number}\n*/\n\n\nGfxElement.prototype.getScaledWidth = function () {\n  return this.getWidth() * this.getTotalScaleX();\n};\n/**\n* Return this elements height.\n* @abstract\n* @return {number}\n*/\n\n\nGfxElement.prototype.getHeight = function () {\n  return this._height;\n};\n/**\n* Return this element's height, incorporating screen and element-local scaling.\n* @return {number}\n*/\n\n\nGfxElement.prototype.getScaledHeight = function () {\n  return this.getHeight() * this.getTotalScaleY();\n};\n/** Get the amount of rotation, ignoring any base rotation.\n* @return {number} The rotation in radians.\n* @see GfxElement#setBaseRotation\n*/\n\n\nGfxElement.prototype.getUnAdjustedRotation = function () {\n  return this._rotation;\n};\n/** Get the base rotation.\n* @return {number} The rotation in radians.\n* @see GfxElement#setBaseRotation\n*/\n\n\nGfxElement.prototype.getBaseRotation = function () {\n  return this._baseRotation;\n};\n/** Get the total effective rotation of the element, including base rotation.\n* @return {number} The rotation in radians.\n* @see GfxElement#setBaseRotation\n*/\n\n\nGfxElement.prototype.getRotation = function () {\n  if (this._rotation || this._baseRotation) return (this._rotation || 0) + (this._baseRotation || 0);\n  return null;\n};\n/** Rotate the element by a specified number of radians.\n* @param {number} rotation The rotation in radians.\n*/\n\n\nGfxElement.prototype.setRotation = function (rotation) {\n  this._rotation = rotation;\n\n  if (this._rotation === null) {\n    if (this.wasRotated()) this.setDirty(true);\n    return;\n  }\n\n  this._recalculateRotatedCollisionBox();\n\n  this.setDirty(true);\n};\n/** Set a base rotation for this element.  Calling setRotation\n* will apply the rotation on top of any base rotation.\n* @param {number} rotation The rotation in radians.\n*/\n\n\nGfxElement.prototype.setBaseRotation = function (rotation) {\n  this._baseRotation = rotation;\n\n  if (this._baseRotation === null) {\n    if (this.wasRotated()) this.setDirty(true);\n    return;\n  }\n\n  this._recalculateRotatedCollisionBox();\n\n  this.setDirty(true);\n};\n/** @private */\n\n\nGfxElement.prototype.wasRotated = function () {\n  return this._wasRotated;\n};\n/** @private */\n\n\nGfxElement.prototype.setWasRotated = function (wasRotated) {\n  this._wasRotated = wasRotated;\n};\n/** Return whether this element is rotated.  Ignores base rotation.\n* @return {number} The rotation in radians.\n*/\n\n\nGfxElement.prototype.hasRotation = function () {\n  return !(Utils.isNullOrUndefined(this.getRotation()) || this.getRotation() === 0);\n};\n/** @private */\n\n\nGfxElement.prototype.getRotatedScaledX = function () {\n  return this._rotatedScaledX;\n};\n/** @private */\n\n\nGfxElement.prototype.getRotatedScaledY = function () {\n  return this._rotatedScaledY;\n};\n/** @private */\n\n\nGfxElement.prototype.getScaledDiagonalSize = function () {\n  return this._scaledDiagonalSize;\n};\n/** @private */\n\n\nGfxElement.prototype._recalculateRotatedCollisionBox = function () {\n  if (this.getRotation() === null) return;\n  this._scaledDiagonalSize = Math.ceil(Math.sqrt(Math.pow(this.getScaledWidth(), 2) + Math.pow(this.getScaledHeight(), 2)));\n  this._rotatedScaledX = Math.floor(this.getScaledX() - (this._scaledDiagonalSize - this.getScaledWidth()) / 2);\n  this._rotatedScaledY = Math.floor(this.getScaledY() - (this._scaledDiagonalSize - this.getScaledHeight()) / 2);\n};\n/** Return whether the element is flipped horizontally.\n* @return {bool}\n*/\n\n\nGfxElement.prototype.isHorizontallyFlipped = function () {\n  return this._horizontalFlip;\n};\n/** Return whether the element is flipped vertically.\n* @return {bool}\n*/\n\n\nGfxElement.prototype.isVerticallyFlipped = function () {\n  return this._verticalFlip;\n};\n/** Set whether to horizontally flip this element.\n* @param {bool} flipped If true, flip the element; false, do not.\n*/\n\n\nGfxElement.prototype.setHorizontallyFlipped = function (flipped) {\n  if (this._horizontalFlip !== flipped) this.setDirty(true);\n  this._horizontalFlip = flipped;\n};\n/** Set whether to vertically flip this element.\n* @param {bool} flipped If true, flip the element; false, do not.\n*/\n\n\nGfxElement.prototype.setVerticallyFlipped = function (flipped) {\n  if (this._verticalFlip !== flipped) this.setDirty(true);\n  this._verticalFlip = flipped;\n};\n/** Make the element flash.\n* @param {number} interval How frequently, in milliseconds to flash the element.\n* @param {number} duration How long to keep flashing. If duration is -1, will flash until turned off.\n* @param {function} callback A function to call when flashing ends.\n*/\n\n\nGfxElement.prototype.flash = function (interval, duration, callback) {\n  this._flashInterval = interval;\n  this._flashDuration = duration;\n  this._isFlashing = true;\n  this._flashStartTime = -1;\n  this._flashElapsed = 0;\n  this._flashHidden = false;\n  this._flashDoneCallback = callback;\n};\n/** Return whether the element is currenlyt flashing.\n* @return {bool}\n*/\n\n\nGfxElement.prototype.isFlashing = function () {\n  return this._isFlashing;\n};\n/** Turn flashing off.  If a callback was provided when flash was turned on, it will be turned off.\n*/\n\n\nGfxElement.prototype.turnFlashOff = function () {\n  this._endFlash();\n};\n/** @private */\n\n\nGfxElement.prototype._endFlash = function () {\n  this._isFlashing = false;\n  this._flashStartTime = -1;\n  this._flashElapsed = 0;\n  this._flashHidden = false;\n  if (Utils.isFunction(this._flashDoneCallback)) this._flashDoneCallback();\n};\n/** @private */\n\n\nGfxElement.prototype._updateFlash = function (time, diff) {\n  if (this._flashStartTime === -1) this._flashStartTime = time;\n\n  if (time - this._flashStartTime >= this._flashDuration && this._flashDuration > -1) {\n    this._endFlash();\n\n    return;\n  }\n\n  this._flashElapsed += diff;\n\n  if (this._flashElapsed >= this._flashInterval) {\n    this._flashElapsed -= this._flashInterval;\n    this._flashHidden = !this._flashHidden;\n    this.setDirty(true);\n  }\n};\n/** Nudge the element, make it move back and forth rapidly.  Provides options for decays of movement range\n* (will make movement less extreme over time), and of time interval (movement becomes more rapid over time).\n* Automatically returns to its starting position upon completion.\n* If the offsets or the interval time reaches zero due to the decay parameters, the nudge will finish.\n* Will throw an error if the parameters will cause the nudge to repeat for >= 1000 intervals.\n* @param {number} offsetX The maximum (positive and negative) horizontal offset to move the element.\n* @param {number} offsetY The maximum (positive and negative) vertical offset to move the element.\n* @param {number} decay After hitting the current offset and reversing direction, reduce the offsets by this amount.\n* @param {number} interval How rapidly (milliseconds) the element should move to the offset, before reversing direction.\n* @param {number} intervalDecay Reduces the interval time after each iteration.\n* @param {function} callback A function to call when the nudge has completed.\n* @fires GfxElement#ELEMENT_STARTED_MOVING\n* @fires GfxElement#ELEMENT_STOPPED_MOVING\n*/\n\n\nGfxElement.prototype.nudge = function (offsetX, offsetY, decay, interval, intervalDecay, callback) {\n  if (interval < 0) throw new Error(\"interval cannot be less than 0\");\n  this._nudgeDoneCallback = callback;\n  var tx, ty;\n  var xdir = offsetX >= 0 ? 1 : -1;\n  var ydir = offsetY >= 0 ? 1 : -1;\n  var count = 0;\n\n  while ((Math.abs(offsetX) > decay || Math.abs(offsetY) > decay) && interval >= 0) {\n    tx = this.getX() + offsetX;\n    ty = this.getY() + offsetY; // Add movement to the queue.\n\n    this.moveTo(tx, ty, interval);\n    this._isProcessingNudge = true;\n    interval -= intervalDecay;\n    xdir = xdir * -1;\n    ydir = ydir * -1;\n    offsetX = offsetX !== 0 ? xdir * (Math.abs(offsetX) - decay) : 0;\n    offsetY = offsetY !== 0 ? ydir * (Math.abs(offsetY) - decay) : 0;\n    count++;\n    if (count > 1000) throw new Error(\"GfxElement.nudge() looped too many times.\");\n  }\n\n  this.moveTo(this.getX(), this.getY(), interval < 0 ? 0 : interval);\n};\n/** Shake the element in random directions, up to a maximum range.  Provides options for decays of movement range\n* (will make movement less extreme over time), and of time interval (movement becomes more rapid over time).\n* If the intensity or the interval time reaches zero due to the decay parameters, the shake will finish.\n* Automatically returns to its starting position upon completion.\n* Will throw an error if the parameters will cause the nudge to repeat for >= 1000 intervals.\n* @param {number} intensity The maximum (positive and negative) range the element will move in any direction.\n* @param {number} intensityDecay After each movement interval, reduce the intensity by this amount.\n* @param {number} interval How rapidly (milliseconds) the element should move to the offset, before starting a new iteration.\n* @param {number} intervalDecay Reduces the interval time after each iteration.\n* @param {number} notToExceedTime An upper limit in milliseconds to allow the shake to process.\n* @param {function} [callback] A function to call when the shake has completed.\n* @fires GfxElement#ELEMENT_STARTED_MOVING\n* @fires GfxElement#ELEMENT_STOPPED_MOVING\n*/\n\n\nGfxElement.prototype.shake = function (intensity, intensityDecay, interval, intervalDecay, notToExceedTime, callback) {\n  if (interval < 0) throw new Error(\"interval cannot be less than 0\");\n  if (intervalDecay === 0 && !notToExceedTime) throw new Error(\"must specify either intervalDecay or notToExceedTime\");\n  this._shakeDoneCallback = callback;\n  var tx, ty;\n  var count = 0;\n  var elapsed = 0;\n  var offsetX = intensity - Math.floor(Math.random() * intensity * 2);\n  var offsetY = intensity - Math.floor(Math.random() * intensity * 2);\n\n  while (intensity > 0 && interval > 0 && elapsed < (notToExceedTime || Number.POSITIVE_INFINITY)) {\n    tx = this.getX() + offsetX;\n    ty = this.getY() + offsetY;\n    this.moveTo(tx, ty, interval);\n    this._isProcessingShake = true;\n    elapsed += interval;\n    interval -= intervalDecay;\n    intensity -= intensityDecay;\n    offsetX = intensity - Math.floor(Math.random() * intensity * 2);\n    offsetY = intensity - Math.floor(Math.random() * intensity * 2);\n    count++;\n    if (count > 1000) throw new Error(\"GfxElement.shake() looped too many times.\");\n  }\n\n  this.moveTo(this.getX(), this.getY(), interval < 0 ? 0 : interval);\n};\n/** Set the horizontal and vertical movement rates for this element.\n* Rates will be treated as approximately pixels per second.\n* Negative values will move the element left for xMoveRate or up for yMoveRate.\n* Zero values will halt movement on a given axis.\n* Positive values will move the element right for xMoveRate or down for yMoveRate.\n* Note that moveTo instructions will supercede movement rates in determining the element's position.\n* @param {number} xMoveRate Horizontal movement rate\n* @param {number} yMoveRate Vertical movement rate\n* @fires GfxElement#ELEMENT_STOPPED_MOVING\n* @fires GfxElement#ELEMENT_STARTED_MOVING\n*/\n\n\nGfxElement.prototype.setMoveRates = function (xMoveRate, yMoveRate) {\n  if (xMoveRate === 0 && yMoveRate === 0 && this._currentMove === null && (this._xMoveRate !== 0 || this._yMoveRate !== 0)) {\n    this.notify(new Event(EventType.ELEMENT_STOPPED_MOVING, {\n      element: this\n    }));\n  } else if ((xMoveRate !== 0 || yMoveRate !== 0) && this._currentMove === null && this._xMoveRate === 0 && this._yMoveRate === 0) {\n    this.notify(new Event(EventType.ELEMENT_STARTED_MOVING, {\n      element: this\n    }));\n  }\n\n  this._xMoveRate = xMoveRate;\n  this._yMoveRate = yMoveRate;\n};\n/**\n* Return the current x movement rate.\n* @return {number}\n*/\n\n\nGfxElement.prototype.getMoveRateX = function () {\n  return this._xMoveRate;\n};\n/**\n* Return the current y movement rate.\n* @return {number}\n*/\n\n\nGfxElement.prototype.getMoveRateY = function () {\n  return this._yMoveRate;\n};\n/**\n* Move the element to the specified coordinate over the course of specified duration.\n* Calls to this method are queued and executed one after the other.\n* Note that movement effect created by this method will supercede any movement rates for the given duration.\n* @param {number} x The target x coordinate\n* @param {number} y The target y coordinate\n* @param {number} duration Optional. How long it should take the element to move from its current position to the target position, in milliseconds. Defaults to 16ms.\n* @param {function} callback Optional.  The function to call when the move is complete.\n* @fires GfxElement#ELEMENT_STARTED_MOVING\n* @fires GfxElement#ELEMENT_STOPPED_MOVING\n*/\n\n\nGfxElement.prototype.moveTo = function (x, y, duration, callback) {\n  duration = duration || 16;\n  var moveOrder = new MoveOrder(this, x, y, duration, this.moveOrderCallback.bind(this), callback);\n\n  this._moveQueue.push(moveOrder);\n\n  if (this._currentMove === null) {\n    this._runMove(); // If not already moving, fire start move event\n\n\n    if (this.getMoveRateX() === 0 && this.getMoveRateY() === 0) {\n      this.notify(new Event(EventType.ELEMENT_STARTED_MOVING, {\n        element: this\n      }));\n    }\n  }\n};\n/** @private */\n\n\nGfxElement.prototype._runMove = function () {\n  if (this._moveQueue.size() > 0) {\n    this._currentMove = this._moveQueue.pop();\n\n    this._currentMove.start();\n\n    return true;\n  } // If no additional movement, fire end move event\n\n\n  if (this.getMoveRateX() === 0 && this.getMoveRateY() === 0) {\n    this.notify(new Event(EventType.ELEMENT_STOPPED_MOVING, {\n      element: this\n    }));\n  }\n\n  this._currentMove = null;\n  return false;\n};\n/** @private */\n\n\nGfxElement.prototype.moveOrderCallback = function () {\n  this._currentMove = null;\n\n  if (!this._runMove()) {\n    if (this._isProcessingNudge) {\n      if (Utils.isFunction(this._nudgeDoneCallback)) this._nudgeDoneCallback();\n      this._isProcessingNudge = false;\n    }\n\n    if (this._isProcessingShake) {\n      if (Utils.isFunction(this._shakeDoneCallback)) this._shakeDoneCallback();\n      this._isProcessingShake = false;\n    }\n  }\n};\n/**\n* Clear any queued moveTo instructions.\n* Does not effect a currently running moveTo, or any movement rates.\n*/\n\n\nGfxElement.prototype.clearMoveQueue = function () {\n  this._moveQueue.clear();\n};\n/**\n* Turn the element \"off\".\n* All movement will cease and element will be hidden.\n*/\n\n\nGfxElement.prototype.turnOff = function () {\n  this._moveQueue.clear();\n\n  this._currentMove = null;\n  this._xMoveRate = 0;\n  this._xMoveFractionalAccumulator = 0;\n  this._yMoveRate = 0;\n  this._yMoveFractionalAccumulator = 0;\n  this.hide();\n};\n/** Show the element. */\n\n\nGfxElement.prototype.show = function () {\n  this._hidden = false;\n  this.setDirty(true);\n};\n/** Hide the element */\n\n\nGfxElement.prototype.hide = function () {\n  this._hidden = true;\n  this.setDirty(true);\n};\n/** Called by the parent layer. Update the element.  Will update location based on current time/diff.\n* @param {number} time The current time.  Not specifically used, but provided for extension.\n* @param {number} diff The difference between the previous time and the current time. Use to calculate element's position if it is moving.\n* @return {GfxElement} Returns this element if it needs to be redrawn, null otherwise.\n* @fires GfxElement#ELEMENT_MOVED\n*/\n\n\nGfxElement.prototype.update = function (time, diff) {\n  this._updateLocationFromMoveRates(time, diff); // Will take precedence over move rate\n\n\n  this._updateMoveOrder(time, diff);\n\n  if (this._isFlashing) this._updateFlash(time, diff);\n\n  if (this.getX() !== this.getLastX() || this.getY() !== this.getLastY()) {\n    this.setDirty(true);\n    this.notify(new Event(EventType.ELEMENT_MOVED, {\n      element: this\n    }, time));\n  }\n\n  if (this.isDirty()) {\n    this._recalculateRotatedCollisionBox();\n\n    return this;\n  }\n\n  return null;\n};\n/** Updates the elements position using movement rates and the time diff.\n* @private\n* @param {number} time\n* @param {number} diff\n*/\n\n\nGfxElement.prototype._updateLocationFromMoveRates = function (time, diff) {\n  var amount, sign, intAmount;\n\n  if (this._xMoveRate !== 0) {\n    amount = this._xMoveFractionalAccumulator + diff * this._xMoveRate / 1000;\n    sign = Math.sign(amount);\n    intAmount = Math.trunc(amount);\n    this._xMoveFractionalAccumulator = sign * (Math.abs(amount) - Math.abs(intAmount));\n    this._x += intAmount;\n    if (this._x !== this._lastX) this.setDirty(true);\n  } else {\n    this._xMoveFractionalAccumulator = 0;\n  }\n\n  if (this._yMoveRate !== 0) {\n    amount = this._yMoveFractionalAccumulator + diff * this._yMoveRate / 1000;\n    sign = Math.sign(amount);\n    intAmount = Math.trunc(amount);\n    this._yMoveFractionalAccumulator = sign * (Math.abs(amount) - Math.abs(intAmount));\n    this._y += intAmount;\n    if (this._y !== this._lastY) this.setDirty(true);\n  } else {\n    this._yMoveFractionalAccumulator = 0;\n  }\n};\n/** Updates the elements position based on the current moveTo instruction.\n* @private\n* @param {number} time\n* @param {number} diff\n*/\n\n\nGfxElement.prototype._updateMoveOrder = function (time, diff) {\n  if (this._currentMove !== null) {\n    this._currentMove.update(time, diff);\n\n    this.setDirty(true);\n  }\n};\n/** Intended for immediately clearing this element's bounding box. \n * Called by the parent layer. Time parameters are not used, just made available here for extension.\n * @param {CanvasContext} canvasContext \n* @param {number} time\n* @param {number} diff\n*/\n\n\nGfxElement.prototype.clear = function (canvasContext, time, diff) {\n  canvasContext.clearRect(this._lastCollisionBoxX, this._lastCollisionBoxY, this._lastCollisionBoxWidth, this._lastCollisionBoxHeight);\n};\n/** Called by the parent layer. Perform any preRendering steps, return whether the element needs to be rendered.\n*/\n\n\nGfxElement.prototype.preRender = function (time, diff) {\n  if (!this.isHidden() && !this._flashHidden && this.isDirty()) return true;\n  return false;\n};\n/** Called by the parent layer.\n* The render method should be implemented in subclasses.\n* Time parameters provided for extension.\n*/\n\n\nGfxElement.prototype.render = function (canvasContext, time, diff) {\n  throw new Error(\"Not Implemented.\");\n};\n/** Called by the parent layer.\n* Provides post-render clean up.\n* Time parameters provided for extension.\n* @param {number} time\n* @param {number} diff\n*/\n\n\nGfxElement.prototype.postRender = function (time, diff) {\n  this.setLastX(this.getX());\n  this.setLastY(this.getY());\n\n  if (this.hasRotation()) {\n    this.setWasRotated(true);\n  } else this.setWasRotated(false);\n\n  this._saveLastCollisionBox();\n\n  this._hadCollisionPreviousFrame = this.hasCollision();\n  this.setHasCollision(false);\n  this.setDirty(false);\n};\n/** @private */\n\n\nGfxElement.prototype._saveLastCollisionBox = function () {\n  this._lastCollisionBoxX = this.getCollisionBoxX();\n  this._lastCollisionBoxY = this.getCollisionBoxY();\n  this._lastCollisionBoxWidth = this.getCollisionBoxWidth();\n  this._lastCollisionBoxHeight = this.getCollisionBoxHeight();\n};\n/** Check whether this element collidesWith another element.\n* Compares the boundaries of this element and the other to check for overlap; if so return true, else return false.\n* @param {GfxElement} element\n* @return {boolean}\n* @fires GfxElement#ELEMENT_COLLISION\n*/\n\n\nGfxElement.prototype.collidesWith = function (element) {\n  var thisX = this.getCollisionBoxX();\n  var thatX = element.getCollisionBoxX();\n  var thisWidth = this.getCollisionBoxWidth();\n  var thatWidth = element.getCollisionBoxWidth();\n  var thisY = this.getCollisionBoxY();\n  var thatY = element.getCollisionBoxY();\n  var thisHeight = this.getCollisionBoxHeight();\n  var thatHeight = element.getCollisionBoxHeight();\n  var result = thisX < thatX + thatWidth && thisX + thisWidth > thatX && thisY < thatY + thatHeight && thisY + thisHeight > thatY;\n  /* Internally, we may need to redraw if one of the elements was recently hidden.\n  * However, don't trigger the event if either element is hidden.\n  */\n\n  if (result && !this.isHidden() && !element.isHidden()) {\n    this.notify(new Event(EventType.ELEMENT_COLLISION, {\n      element1: this,\n      element2: element\n    })); // notify the other element of the collision\n\n    element.notify(new Event(EventType.ELEMENT_COLLISION, {\n      element1: element,\n      element2: this\n    }));\n  }\n\n  return result;\n};\n/** Check whether this element intersects a specific point on the screen.\n* @param {number} x\n* @param {number} y\n* @return {boolean}\n*/\n\n\nGfxElement.prototype.collidesWithCoordinates = function (x, y) {\n  var result = x >= this.getCollisionBoxX() && x <= this.getCollisionBoxX() + this.getCollisionBoxWidth() && y >= this.getCollisionBoxY() && y <= this.getCollisionBoxY() + this.getCollisionBoxHeight();\n  return result;\n};\n/** Check whether this element intersects an x coordinate.\n* @param {number} x\n* @return {boolean}\n*/\n\n\nGfxElement.prototype.collidesWithX = function (x) {\n  var result = x >= this.getCollisionBoxX() && x <= this.getCollisionBoxX() + this.getCollisionBoxWidth();\n  return result;\n};\n/** Check whether this element intersects an y coordinate.\n* @param {number} x\n* @return {boolean}\n*/\n\n\nGfxElement.prototype.collidesWithY = function (y) {\n  var result = y >= this.getCollisionBoxY() && y <= this.getCollisionBoxY() + this.getCollisionBoxHeight();\n  return result;\n};\n/** Returns the x value of the collision box.  Incorporates screen scale.\n* @return {number}\n*/\n\n\nGfxElement.prototype.getCollisionBoxX = function () {\n  if (this.hasRotation()) return this.getRotatedScaledX() + GfxElement.AntiAliasCorrection.coordinateOffset;\n  return this.getScaledX() + GfxElement.AntiAliasCorrection.coordinateOffset;\n};\n/** Returns the y value of the collision box.  Incorporates screen scale.\n* @return {number}\n*/\n\n\nGfxElement.prototype.getCollisionBoxY = function () {\n  if (this.hasRotation()) return this.getRotatedScaledY() + GfxElement.AntiAliasCorrection.coordinateOffset;\n  return this.getScaledY() + GfxElement.AntiAliasCorrection.coordinateOffset;\n};\n/** Returns the width value of the collision box.  Incorporates total scale.\n* @return {number}\n*/\n\n\nGfxElement.prototype.getCollisionBoxWidth = function () {\n  if (this.hasRotation()) return this.getScaledDiagonalSize() + GfxElement.AntiAliasCorrection.sizeAdjustment;\n  return this.getScaledWidth() + GfxElement.AntiAliasCorrection.sizeAdjustment;\n};\n/** Returns the height value of the collision box.  Incorporates total scale.\n* @return {number}\n*/\n\n\nGfxElement.prototype.getCollisionBoxHeight = function () {\n  if (this.hasRotation()) return this.getScaledDiagonalSize() + GfxElement.AntiAliasCorrection.sizeAdjustment;\n  return this.getScaledHeight() + GfxElement.AntiAliasCorrection.sizeAdjustment;\n};\n/** Fires events if the mouse event is on this element.<br />\n* @fires GfxElement#MOUSE_ENTER_ELEMENT\n* @fires GfxElement#MOUSE_EXIT_ELEMENT\n* @fires GfxElement#MOUSE_MOVE_OVER_ELEMENT\n* @fires GfxElement#MOUSE_DOWN_ON_ELEMENT\n* @fires GfxElement#MOUSE_UP_ON_ELEMENT\n* @param {Event}\n*/\n\n\nGfxElement.prototype.handleMouseEvent = function (event) {\n  var eventData = this._setupSecondaryEventData(event);\n\n  var secondaryEvents = []; // GfxElement will use screen scaled coordinates for comparison;\n  // so, don't use final x & y from event, but rather use scaled values\n  // TODO: name things better to make them less confusing?\n\n  if (this.collidesWithCoordinates(event.data.viewOriginAdjustedX, event.data.viewOriginAdjustedY)) {\n    if (!this.isMouseOver()) {\n      secondaryEvents.push(new MouseEvent(EventType.MOUSE_ENTER_ELEMENT, eventData, event.data.time));\n    }\n\n    this._mouseIsOver = true;\n    var type = null;\n\n    switch (event.type) {\n      case EventType.MOUSE_MOVE:\n        type = EventType.MOUSE_MOVE_OVER_ELEMENT;\n        break;\n\n      case EventType.MOUSE_DOWN:\n        type = EventType.MOUSE_DOWN_ON_ELEMENT;\n        break;\n\n      case EventType.MOUSE_UP:\n        type = EventType.MOUSE_UP_ON_ELEMENT;\n        break;\n    }\n\n    secondaryEvents.push(new MouseEvent(type, eventData, event.data.time));\n  } else {\n    if (this.isMouseOver()) {\n      secondaryEvents.push(new MouseEvent(EventType.MOUSE_EXIT_ELEMENT, eventData, event.data.time));\n      this._mouseIsOver = false;\n    }\n  }\n\n  for (var i = 0; i < secondaryEvents.length; i++) {\n    var secondaryEvent = secondaryEvents[i];\n    this.notify(secondaryEvent);\n    if (secondaryEvent.endEventPropagation) event.endEventPropagation = true;\n  }\n};\n/** @private */\n\n\nGfxElement.prototype._setupSecondaryEventData = function (event) {\n  var eventData = {\n    x: event.data.x,\n    y: event.data.y,\n    viewOriginAdjustedX: event.data.viewOriginAdjustedX,\n    viewOriginAdjustedY: event.data.viewOriginAdjustedY,\n    rawX: event.data.rawX,\n    rawY: event.data.rawY,\n    element: this\n  };\n  return eventData;\n};\n\nmodule.exports = GfxElement;\n/** Element stopped moving.\n* @event GfxElement#ELEMENT_STOPPED_MOVING\n* @type {ElementEvent}\n*/\n\n/** Element started moving.\n* @event GfxElement#ELEMENT_STARTED_MOVING\n* @type {ElementEvent}\n*/\n\n/** Element Moved.\n* @event GfxElement#ELEMENT_MOVED\n* @type {ElementEvent}\n*/\n\n/** An element collided with another element.\n* @event GfxElement#ELEMENT_COLLISION\n* @type {ElementCollidesWithElementEvent}\n*/\n\n/** Mouse moves into the element's coolision box.\n* @event GfxElement#MOUSE_ENTER_ELEMENT\n* @type {ElementMouseEvent}\n*/\n\n/** Mouse moves inside the element's coolision box.\n* @event GfxElement#MOUSE_MOVE_OVER_ELEMENT\n* @type {ElementMouseEvent}\n*/\n\n/** Mouse button down on an element.\n* @event GfxElement#MOUSE_DOWN_ON_ELEMENT\n* @type {ElementMouseEvent}\n*/\n\n/** Mouse button up on element.\n* @event GfxElement#MOUSE_UP_ON_ELEMENT\n* @type {ElementMouseEvent}\n*/\n\n/** Mouse leaves the element's coolision box.\n* @event GfxElement#MOUSE_EXIT_ELEMENT\n* @type {ElementMouseEvent}\n*/\n\n//# sourceURL=webpack:///./src/GfxElement.js?");

/***/ }),

/***/ "./src/GfxElementZIndexComparable.js":
/*!*******************************************!*\
  !*** ./src/GfxElementZIndexComparable.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** Comparable for a GfxElement.  Used by GfxLayer to determine rendering order.\n* @constructor\n* @implements {IComparable}\n* @param {GfxElement} parentElement The element to create this comparable for.\n*/\nfunction GfxElementZIndexComparable(parentElement) {\n  this._parentElement = parentElement;\n}\n\n;\n/** Returns the element for this elementComparable.\n* @returns {GfxElement}\n*/\n\nGfxElementZIndexComparable.prototype.getElement = function () {\n  return this._parentElement;\n};\n/**\n* @implements {IComparable.compareTo}\n* @param {GfxElementZIndexComparable} other The object to compare to this one.\n* @returns {int} -1: less than the other object; 0 equivalent to the other object; 1 greater than the other object.\n*/\n\n\nGfxElementZIndexComparable.prototype.compareTo = function (other) {\n  if (this._parentElement.getZIndex() < other._parentElement.getZIndex()) return -1;\n  if (this._parentElement.getZIndex() === other._parentElement.getZIndex()) return 0;\n  return 1;\n};\n/**\n* @implements {IComparable.equals}\n* @param {GfxElementZIndexComparable} other The object to compare to this one.\n* @returns {boolean} true if elements are equivalent, false otherwise.\n*/\n\n\nGfxElementZIndexComparable.prototype.equals = function (other) {\n  return this._parentElement.getZIndex() === other._parentElement.getZIndex();\n};\n/**Returns this comparables key (uses Id from parent element).\n* Implementation for getKey for UniquePriorityQueue\n* @returns {int}\n*/\n\n\nGfxElementZIndexComparable.prototype.getKey = function () {\n  return this._parentElement.getId();\n};\n\nmodule.exports = GfxElementZIndexComparable;\n\n//# sourceURL=webpack:///./src/GfxElementZIndexComparable.js?");

/***/ }),

/***/ "./src/GfxLayer.js":
/*!*************************!*\
  !*** ./src/GfxLayer.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var UniquePriorityQueue = __webpack_require__(/*! slcommon/src/UniquePriorityQueue */ \"./node_modules/slcommon/src/UniquePriorityQueue.js\");\n\nvar Utils = __webpack_require__(/*! slcommon/src/Utils */ \"./node_modules/slcommon/src/Utils.js\");\n\nvar Event = __webpack_require__(/*! slcommon/src/Event */ \"./node_modules/slcommon/src/Event.js\");\n\nvar EventType = __webpack_require__(/*! ../src/EventType */ \"./src/EventType.js\");\n\nvar Layer = __webpack_require__(/*! ./Layer */ \"./src/Layer.js\");\n/** Graphics layer.\n* Generally, the use of Screen.createLayer(\"GfxLayer\") is preferred over creating layer by hand.\n* @constructor\n* @augments Layer\n* @param {Object} props The properties to create this layer with. <br />\n* @param {Screen} props.screenContext The parent screen for this layer.\n* @param {CanvasContextWrapper} props.canvasContextWrapper The canvasContextWrapper. This layer will draw to the canvas' context, via wrapper's exposed methods.\n* @param {number} props.width The width of the layer.  Should match Screen.\n* @param {number} props.height The height of the layer.  Should match Screen.\n*/\n\n\nfunction GfxLayer(props) {\n  props = props || {};\n  Layer.call(this, props);\n  this._elements = [];\n  this._dirtyElements = new UniquePriorityQueue();\n\n  this._dirtyElements.setInvertPriority(false);\n\n  this._removedElements = {};\n  this._zIndexCounter = 0; // If \"removeAllElements()\" was called, this flag allows cleanup to do so more efficiently.\n\n  this._allElementsRemoved = false;\n}\n\n;\nGfxLayer.prototype = new Layer();\nGfxLayer.prototype.constructor = GfxLayer;\n/** Add a GfxElement to this layer.\n* @param {GfxElement} element\n*/\n\nGfxLayer.prototype.addElement = function (element) {\n  this._elements.push(element); // give a natural ordering to elements added with no specific zIndex\n  // prevent render order swapping and element \"switching\" places\n\n\n  if (element.getZIndex() === -1) {\n    element.setZIndex(this._zIndexCounter++);\n  }\n};\n/** Remove an element from the layer.\n* @param {int} id The id of the element to remove\n* @return {GfxElement} The removed element, if found.\n*/\n\n\nGfxLayer.prototype.removeElementById = function (id) {\n  var idx = Utils.linSearch(this._elements, id, function (element, value) {\n    return element.getId() === value;\n  });\n\n  if (idx > -1) {\n    return this._removeElementByIndex(idx);\n  }\n\n  return null;\n};\n/** Remove an element from the layer.\n* @param {GfxElement} element The element to remove\n* @return {GfxElement} The removed element, if found.\n*/\n\n\nGfxLayer.prototype.removeElement = function (element) {\n  return this.removeElementById(element.getId());\n};\n/** Does not bounds check.\n* @private\n*/\n\n\nGfxLayer.prototype._removeElementByIndex = function (idx) {\n  this._removedElements[this._elements[idx].getId()] = this._elements[idx];\n  var elem = this._elements[idx]; // ensure it gets cleared\n\n  elem.setDirty(true);\n  elem.setHidden(true);\n\n  this._dirtyElements.push(elem.getZIndexComparable());\n\n  return elem;\n};\n/** Remove all elements from the layer.\n*/\n\n\nGfxLayer.prototype.removeAllElements = function () {\n  for (var i = 0; i < this._elements.length; i++) {\n    this._removeElementByIndex(i);\n  }\n\n  this._allElementsRemoved = true;\n};\n/** Update the layer.\n* Calls update on each element belonging to this layer.\n* Checks for elements colliding with the layer boundary and emits events accordingly (event emitted from the elements themselves):\n* The ELEMENT_HIT_<X> events will send the following properties in the data for the events:\n* <ul>\n* <li>element : The element that hit the border</li>\n* <li>layer : This layer</li>\n* </ul>\n* @param {number} time The current time (milliseconds)\n* @param {number} diff The difference between the last time and the current time  (milliseconds)\n* @fires GfxLayer#ELEMENT_HIT_LEFT_EDGE\n* @fires GfxLayer#ELEMENT_HIT_RIGHT_EDGE\n* @fires GfxLayer#ELEMENT_HIT_TOP_EDGE\n* @fires GfxLayer#ELEMENT_HIT_BOTTOM_EDGE\n*/\n\n\nGfxLayer.prototype.update = function (time, diff) {\n  var dirtyElement;\n  var i;\n\n  for (i = 0; i < this._elements.length; i++) {\n    // ensure all elements are redrawn if the layer is dirty\n    if (this.isDirty()) this._elements[i].setDirty(true);\n    dirtyElement = this._elements[i].update(time, diff);\n\n    if (dirtyElement) {\n      this._dirtyElements.push(this._elements[i].getZIndexComparable());\n    }\n\n    this._checkBorderCollision(this._elements[i], time);\n  }\n\n  this._handleCollisions();\n};\n/** @private */\n\n\nGfxLayer.prototype._checkBorderCollision = function (element, time) {\n  if (element.getCollisionBoxX() <= 0) {\n    element.notify(new Event(EventType.ELEMENT_HIT_LEFT_EDGE, {\n      layer: this,\n      element: element\n    }, time));\n  }\n\n  if (element.getCollisionBoxX() + element.getCollisionBoxWidth() > this.getWidth()) {\n    element.notify(new Event(EventType.ELEMENT_HIT_RIGHT_EDGE, {\n      layer: this,\n      element: element\n    }, time));\n  }\n\n  if (element.getCollisionBoxY() <= 0) {\n    element.notify(new Event(EventType.ELEMENT_HIT_TOP_EDGE, {\n      layer: this,\n      element: element\n    }, time));\n  }\n\n  if (element.getCollisionBoxY() + element.getCollisionBoxHeight() > this.getHeight()) {\n    element.notify(new Event(EventType.ELEMENT_HIT_BOTTOM_EDGE, {\n      layer: this,\n      element: element\n    }, time));\n  }\n};\n/** @private */\n\n\nGfxLayer.prototype._handleCollisions = function () {\n  var element1, element2, j;\n\n  for (var i = 0; i < this._elements.length - 1; i++) {\n    element1 = this._elements[i];\n\n    for (var j = i + 1; j < this._elements.length; j++) {\n      element2 = this._elements[j];\n\n      this._collisionCheckElementsIfNeeded(element1, element2);\n    }\n  }\n};\n/** @private */\n\n\nGfxLayer.prototype._collisionCheckElementsIfNeeded = function (element1, element2) {\n  if (element1.collidesWith(element2)) {\n    this._updateElementOnCollision(element1);\n\n    this._updateElementOnCollision(element2);\n  }\n};\n/** @private */\n\n\nGfxLayer.prototype._updateElementOnCollision = function (element) {\n  element.setHasCollision(true);\n  element.setDirty(true);\n\n  this._dirtyElements.push(element.getZIndexComparable());\n};\n/** Execute prerendering activities.\n* @override\n* @param {number} time The current time (milliseconds)\n* @param {number} diff The difference between the last time and the current time  (milliseconds)\n*/\n\n\nGfxLayer.prototype.preRender = function (time, diff) {\n  var i;\n  Layer.prototype.preRender.call(this, time, diff); // layer will have been completely cleared if dirty, so no need to clear individual elements\n\n  if (!this.isDirty()) {\n    for (i = 0; i < this._dirtyElements.size(); i++) {\n      this._dirtyElements.getByIndex(i).getElement().clear(this.getCanvasContextWrapper(), time, diff);\n    }\n  }\n};\n/** Render the dirty elements on this layer.\n* Calls clear for all dirty elements first, then calls render on each.\n* Time and diff parameters are not directly used, they are made available for extension purposes, and passed on to clear and render for the same.\n* @param {number} time The current time (milliseconds)\n* @param {number} diff The difference between the last time and the current time  (milliseconds)\n*/\n\n\nGfxLayer.prototype.render = function (time, diff) {\n  while (this._dirtyElements.peek()) {\n    var element = this._dirtyElements.pop().getElement();\n\n    var doRender = element.preRender(time, diff);\n    if (doRender) element.render(this.getCanvasContextWrapper(), time, diff);\n    element.postRender(time, diff);\n  }\n\n  this._cleanUp();\n};\n/** @private */\n\n\nGfxLayer.prototype._cleanUp = function () {\n  if (this._allElementsRemoved) {\n    this._elements = [];\n    this._allElementsRemoved = false;\n  } else {\n    Object.keys(this._removedElements).forEach(function (elementId) {\n      elementId = parseInt(elementId);\n      var idx = Utils.linSearch(this._elements, elementId, function (element, value) {\n        return element.getId() === value;\n      });\n\n      this._elements.splice(idx, 1);\n    }.bind(this));\n  }\n\n  this._removedElements = {};\n\n  this._dirtyElements.clear();\n};\n/** Propagate a mouse event to each of this layers elements.\n* @param {Event} event\n*/\n\n\nGfxLayer.prototype.handleMouseEvent = function (event) {\n  for (var i = 0; i < this._elements.length; i++) {\n    this._elements[i].handleMouseEvent(event);\n  }\n};\n\nmodule.exports = GfxLayer;\n/** An Element hit the left edge of a layer.\n* @event GfxLayer#ELEMENT_HIT_LEFT_EDGE\n* @type {ElementCollidesWithEdgeEvent}\n*/\n\n/** An Element hit the right edge of a layer.\n* @event GfxLayer#ELEMENT_HIT_RIGHT_EDGE\n* @type {ElementCollidesWithEdgeEvent}\n*/\n\n/** An Element hit the top edge of a layer.\n* @event GfxLayer#ELEMENT_HIT_TOP_EDGE\n* @type {ElementCollidesWithEdgeEvent}\n*/\n\n/** An Element hit the bottom edge of a layer.\n* @event GfxLayer#ELEMENT_HIT_BOTTOM_EDGE\n* @type {ElementCollidesWithEdgeEvent}\n*/\n\n//# sourceURL=webpack:///./src/GfxLayer.js?");

/***/ }),

/***/ "./src/ILayerFactory.js":
/*!******************************!*\
  !*** ./src/ILayerFactory.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n* @interface\n*/\nfunction ILayerFactory() {}\n\n;\n/** @abstract */\n\nILayerFactory.prototype.getLayer = function (type, layerProps) {\n  throw new Error(\"getLayer() Not Implemented.\");\n};\n\nmodule.exports = ILayerFactory;\n\n//# sourceURL=webpack:///./src/ILayerFactory.js?");

/***/ }),

/***/ "./src/ImageElement.js":
/*!*****************************!*\
  !*** ./src/ImageElement.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var GfxElement = __webpack_require__(/*! ./GfxElement */ \"./src/GfxElement.js\");\n/** Graphics element that renders part or all of an Image.<br />\n* It is good practice to have a single or few Images that have many tiles on them\n* to make efficient use of memory and screen drawing. Using ImageElement, you\n* can treat tiles from the source image as discrete screen elements that can be\n* moved and interacted with.\n* For animations, see {@link ImageSprite}\n* @constructor\n* @augments GfxElement\n* @param {Object} props The properties for this element.\n* @param {Screen} props.screenContext The target screen.\n* @param {int} [props.scaleX=1] Horizontal scale of this element.  Independent of screen scale.\n* @param {int} [props.scaleY=1] Vertical scale of this element.  Independent of screen scale.\n* @param {boolean} [props.hidden=false] Whether to hide this element.\n* @param {number} [props.x=0] The X coordinate for this element.\n* @param {number} [props.y=0] The Y coordinate for this element.\n* @param {number} [props.rotation=0] The amount of rotation to apply to the element, in radians.  Applied on top of base rotation.\n* @param {number} [props.baseRotation=0] The amount of base rotation to apply to the element, in radians. Usually used to apply an initial, unchanging rotation to the element.  Useful for correcting orientation of images.\n* @param {boolean} [props.horizontalFlip=false] Whether to flip the element horizontally.\n* @param {boolean} [props.verticalFlip=false] Whether to flip the element vertically.\n* @param {number} [props.zIndex=-1] The z-index; elements with higher zIndex values will be drawn later than those with lower values (drawn on top of those with lower values).\n* @param {Image} props.image The image to use for this element. Can be created via html (&lt;img&gt;) or javascript (new Image()).\n* @param {number} props.sourceX The x starting point of the desired subsection of the image\n* @param {number} props.sourceY The y starting point of the desired subsection of the image\n* @param {number} props.sourceWidth The width of the desired subsection of the image\n* @param {number} props.sourceHeight The height of the desired subsection of the image\n* @param {number} props.width The desired width of the ImageElement; if this differs from the source dimensions, the image will be stretched or shrunk accordingly\n* @param {number} props.height The desired height of the ImageElement; if this differs from the source dimensions, the image will be stretched or shrunk accordingly\n* @param {ImageRenderer} props.imageRenderer The ImageRenderer that will draw on the canvas.\n* @see GfxElement\n* @see ImageSprite\n*/\n\n\nfunction ImageElement(props) {\n  props = props || {};\n  GfxElement.call(this, props);\n  this._image = props.image;\n  this._sx = props.sourceX;\n  this._sy = props.sourceY;\n  this._sWidth = props.sourceWidth;\n  this._sHeight = props.sourceHeight;\n  this._imageRenderer = props.imageRenderer;\n}\n\n;\nImageElement.prototype = new GfxElement();\nImageElement.prototype.constructor = ImageElement;\n/** Return the source Image for this element\n* @returns {Image}\n*/\n\nImageElement.prototype.getImage = function () {\n  return this._image;\n};\n/** Return the width for this element\n* @override\n* @returns {number}\n*/\n\n\nImageElement.prototype.getWidth = function () {\n  return this._width;\n};\n/** Return the height for this element\n* @override\n* @returns {number}\n*/\n\n\nImageElement.prototype.getHeight = function () {\n  return this._height;\n};\n/** Return the starting x point on the source Image for this element\n* @returns {number}\n*/\n\n\nImageElement.prototype.getSourceX = function () {\n  return this._sx;\n};\n/** Return the starting y point on the source Image for this element\n* @returns {number}\n*/\n\n\nImageElement.prototype.getSourceY = function () {\n  return this._sy;\n};\n/** Return the width of the subsection of the source Image for this element\n* @returns {number}\n*/\n\n\nImageElement.prototype.getSourceWidth = function () {\n  return this._sWidth;\n};\n/** Return the height of the subsection of the source Image for this element\n* @returns {number}\n*/\n\n\nImageElement.prototype.getSourceHeight = function () {\n  return this._sHeight;\n};\n/** Render the image to the screen.\n* Time and diff parameters are not directly used, they are made available for extension purposes.\n* @param {number} time The current time (milliseconds)\n* @param {number} diff The difference between the last time and the current time  (milliseconds)\n*/\n\n\nImageElement.prototype.render = function (canvasContext, time, diff) {\n  this._imageRenderer.renderImage(canvasContext, this.getImage(), this.getSourceX(), this.getSourceY(), this.getSourceWidth(), this.getSourceHeight(), this.getX(), this.getY(), this.getWidth(), this.getHeight(), this.getElementScaleX(), this.getElementScaleY(), this.isHorizontallyFlipped(), this.isVerticallyFlipped(), this.getRotation());\n};\n\nmodule.exports = ImageElement;\n\n//# sourceURL=webpack:///./src/ImageElement.js?");

/***/ }),

/***/ "./src/ImageLoader.js":
/*!****************************!*\
  !*** ./src/ImageLoader.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Utils = __webpack_require__(/*! ./Utils */ \"./src/Utils.js\");\n\nvar _window = Utils.getWindow();\n/**\n* @class\n* Given an object containing of image paths, will load images and store them back in the object.\n* @param {Object} imagesHash Has of image information. Format {imageId1:{path:path}, imageId1:{path:path}}\n* e.g.,: (warriorSpriteImage1:{path:\"images/warrior1Sprite.png\"}}\n*/\n\n\nfunction ImageLoader(imagesHash) {\n  this.imagesHash = imagesHash;\n  this.imageCount = 0;\n  this.imageLoadedCounter = 0;\n}\n\n;\n\nImageLoader.Image = _window.Image || function () {\n  return {};\n};\n/** Load the images and callback when done.\n* @param {function} callback Will call this function when all images have been loaded.\n*/\n\n\nImageLoader.prototype.loadImages = function (callback) {\n  this.imagesDoneLoadingCallback = callback;\n  var keys = Object.keys(this.imagesHash);\n  this.imageCount = keys.length;\n  var key = null;\n\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    this.imagesHash[key].image = new ImageLoader.Image();\n    this.imagesHash[key].image.src = this.imagesHash[key].path;\n    this.imagesHash[key].image.onload = this.loadImagesCallback.bind(this);\n  }\n};\n/** @private */\n\n\nImageLoader.prototype.loadImagesCallback = function () {\n  this.imageLoadedCounter++;\n\n  if (this.imageLoadedCounter === this.imageCount) {\n    this.imagesDoneLoadingCallback(this.imagesHash);\n  }\n};\n\nmodule.exports = ImageLoader;\n\n//# sourceURL=webpack:///./src/ImageLoader.js?");

/***/ }),

/***/ "./src/ImageRenderer.js":
/*!******************************!*\
  !*** ./src/ImageRenderer.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Utils = __webpack_require__(/*! ./Utils */ \"./src/Utils.js\");\n/** Draws images to a canvas.<br />\n* Can be used to draw all or portions of images to a canvas.\n* @constructor\n* @param {int} screenScaleX Horizontal scale of the Screen\n* @param {int} screenScaleY Vertical scale of the Screen\n* @see ImageElement\n* @see ImageSprite\n*/\n\n\nfunction ImageRenderer(screenScaleX, screenScaleY) {\n  this._screenScaleX = screenScaleX;\n  this._screenScaleY = screenScaleY;\n}\n\n;\n/** Draws an image or portion of an image to the canvas.\n* @param {CanvasContext} context The canvas to draw to.\n* @param {Image} image Image reference, created by &lt;img&gt; or new Image();\n* @param {number} sx The x starting point of a subsection of the image to draw.\n* @param {number} sy The y starting point of a subsection of the image to draw.\n* @param {number} sWidth The width of a subsection of the image to draw.\n* @param {number} sHeight The height of a subsection of the image to draw.\n* @param {number} x The target x position of the canvas to draw the image to.\n* @param {number} y The target y position of the canvas to draw the image to.\n* @param {number} width The target width of the drawn image. If different than the dimensions of the image subsection, the image subsection will be stretched or shrunk.\n* @param {number} height The target height of the drawn image. If different than the dimensions of the image subsection, the image subsection will be stretched or shrunk.\n* @param {int} imageScaleX The amount to scale the drawn image horizontally.\n* @param {int} imageScaleY The amount to scale the drawn image vertically.\n* @param {boolean} isHorizontallyFlipped Whether the element is flipped horizontally.\n* @param {boolean} isVerticallyFlipped Whether the element is flipped vertically.\n* @param {number} rotation The element's rotation in radians.\n*/\n\nImageRenderer.prototype.renderImage = function (context, image, sx, sy, sWidth, sHeight, x, y, width, height, imageScaleX, imageScaleY, flipHorizontally, flipVertically, rotation) {\n  if (flipHorizontally || flipVertically || rotation) {\n    this.renderImageWithTranslation(context, image, sx, sy, sWidth, sHeight, x, y, width, height, imageScaleX, imageScaleY, flipHorizontally, flipVertically, rotation);\n  } else {\n    context.drawImage(image, sx, sy, sWidth, sHeight, x * this.getScreenScaleX(), y * this.getScreenScaleY(), width * this.getTotalScaleX(imageScaleX), height * this.getTotalScaleY(imageScaleY));\n  }\n};\n/** Draws an image or portion of an image to the canvas where the canvas has been translated (rotated/flipped).\n* @param {CanvasContext} context The canvas to draw to.\n* @param {Image} image Image reference, created by &lt;img&gt; or new Image();\n* @param {number} sx The x starting point of a subsection of the image to draw.\n* @param {number} sy The y starting point of a subsection of the image to draw.\n* @param {number} sWidth The width of a subsection of the image to draw.\n* @param {number} sHeight The height of a subsection of the image to draw.\n* @param {number} x The target x position of the canvas to draw the image to.\n* @param {number} y The target y position of the canvas to draw the image to.\n* @param {number} width The target width of the drawn image. If different than the dimensions of the image subsection, the image subsection will be stretched or shrunk.\n* @param {number} height The target height of the drawn image. If different than the dimensions of the image subsection, the image subsection will be stretched or shrunk.\n* @param {int} imageScaleX The amount to scale the drawn image horizontally.\n* @param {int} imageScaleY The amount to scale the drawn image vertically.\n* @param {boolean} isHorizontallyFlipped Whether the element is flipped horizontally.\n* @param {boolean} isVerticallyFlipped Whether the element is flipped vertically.\n* @param {number} rotation The element's rotation in radians.\n*/\n\n\nImageRenderer.prototype.renderImageWithTranslation = function (context, image, sx, sy, sWidth, sHeight, x, y, width, height, imageScaleX, imageScaleY, flipHorizontally, flipVertically, rotation) {\n  var translationX = x * this.getScreenScaleX() + width * this.getTotalScaleX(imageScaleX) / 2;\n  var translationY = y * this.getScreenScaleY() + height * this.getTotalScaleY(imageScaleY) / 2;\n  Utils.renderWithTranslation(context, translationX, translationY, flipHorizontally, flipVertically, rotation, function () {\n    context.drawImageWithTranslation(image, sx, sy, sWidth, sHeight, 0 - width * this.getTotalScaleX(imageScaleX) / 2, 0 - height * this.getTotalScaleY(imageScaleY) / 2, width * this.getTotalScaleX(imageScaleX), height * this.getTotalScaleY(imageScaleY));\n  }.bind(this));\n};\n/**\n* Return the horizontal scale of the renderer.\n* @return {int}\n*/\n\n\nImageRenderer.prototype.getScreenScaleX = function () {\n  return this._screenScaleX;\n};\n/**\n* Return the vertical scale of the renderer.\n* @return {int}\n*/\n\n\nImageRenderer.prototype.getScreenScaleY = function () {\n  return this._screenScaleY;\n};\n/**\n* Return the total horizontal scale (screen scale * image scale).\n* @param {int} imageScaleX The x amount to scale the portion of the image drawn to the canvas.\n* @return {int}\n*/\n\n\nImageRenderer.prototype.getTotalScaleX = function (imageScaleX) {\n  return this._screenScaleX * imageScaleX;\n};\n/**\n* Return the total vertical scale (screen scale * image scale).\n* @param {int} imageScaleY The y amount to scale the portion of the image drawn to the canvas.\n* @return {int}\n*/\n\n\nImageRenderer.prototype.getTotalScaleY = function (imageScaleY) {\n  return this._screenScaleY * imageScaleY;\n};\n\nmodule.exports = ImageRenderer;\n\n//# sourceURL=webpack:///./src/ImageRenderer.js?");

/***/ }),

/***/ "./src/ImageSprite.js":
/*!****************************!*\
  !*** ./src/ImageSprite.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Sprite = __webpack_require__(/*! ./Sprite.js */ \"./src/Sprite.js\");\n\nvar ImageRenderer = __webpack_require__(/*! ./ImageRenderer */ \"./src/ImageRenderer.js\");\n/** Animated element that displays images frames in succession.<br />\n* Uses {@link ImageSpriteFrame} for its frames.\n* @constructor\n* @augments Sprite\n* @param {Object} props Properties for this GfxElement.\n* @param {Screen} props.screenContext The target screen.\n* @param {int} [props.scaleX=1] Horizontal scale of this element.  Independent of screen scale.\n* @param {int} [props.scaleY=1] Vertical scale of this element.  Independent of screen scale.\n* @param {boolean} [props.hidden=false] Whether to hide this element.\n* @param {number} [props.x=0] The X coordinate for this element.\n* @param {number} [props.y=0] The Y coordinate for this element.\n* @param {number} props.width The width of this element.\n* @param {number} props.height The height this element.\n* @param {number} [props.rotation=0] The amount of rotation to apply to the element, in radians.  Applied on top of base rotation.\n* @param {number} [props.baseRotation=0] The amount of base rotation to apply to the element, in radians. Usually used to apply an initial, unchanging rotation to the element.  Useful for correcting orientation of images.\n* @param {boolean} [props.horizontalFlip=false] Whether to flip the element horizontally.\n* @param {boolean} [props.verticalFlip=false] Whether to flip the element vertically.\n* @param {number} [props.zIndex=-1] The z-index; elements with higher zIndex values will be drawn later than those with lower values (drawn on top of those with lower values).\n* @param {Array.<ImageSpriteFrame>} [props.frames=[]] Optional. An array of AnimationFrame's. Default: empty array.\n* @param {number} [props.ttl=-1] Time-to-live.  The time (milliseconds) to continue the Sprites animation.  Default: -1 (unlimited time)\n* @param {boolean} [props.loop=true] Whether to loop the animation or not.\n* @param {int} [props.loopsToLive=-1] If loop is true, the number of loops to execute.  Default: -1 (unlimited loops)\n* @param {int} [props.freezeFrameIdx=-1] When animation completes, switch to the frame indicated by the freeze frame index (referring to the index of the frame in the frames array). Default: -1 (don't change frames when animation stops, stay with the final frame)\n* @param {Image} props.image The image to use for this element. Can be created via html (&lt;img&gt;) or javascript (new Image()).\n* @param {ImageRenderer} props.imageRenderer The ImageRenderer that will draw on the canvas.\n* @see GfxElement\n* @see Sprite\n* @see AnimationFrame\n* @see ImageSpriteFrame\n*/\n\n\nfunction ImageSprite(props) {\n  props = props || {};\n  Sprite.call(this, props);\n  this._image = props.image;\n  this._width = props.width;\n  this._height = props.height;\n  this._imageRenderer = props.imageRenderer;\n}\n\n;\nImageSprite.prototype = new Sprite();\nImageSprite.prototype.constructor = ImageSprite;\n/** Return the source image.\n* @returns {Image}\n*/\n\nImageSprite.prototype.getImage = function () {\n  return this._image;\n};\n/** Render the specified frame.\n* @override\n* @param {number} time The current time (milliseconds).\n* @param {number} diff The difference between the previous render cycle and the current cycle (milliseconds).\n* @param {AnimationFrame} frame The ImageSpriteFrame to be rendered.\n*/\n\n\nImageSprite.prototype.renderFrame = function (canvasContext, time, diff, frame) {\n  this._imageRenderer.renderImage(canvasContext, this.getImage(), frame.getSourceX(), frame.getSourceY(), frame.getSourceWidth(), frame.getSourceHeight(), this.getX(), this.getY(), this.getWidth(), this.getHeight(), this.getElementScaleX(), this.getElementScaleY(), this.isHorizontallyFlipped(), this.isVerticallyFlipped(), this.getRotation());\n};\n\nmodule.exports = ImageSprite;\n\n//# sourceURL=webpack:///./src/ImageSprite.js?");

/***/ }),

/***/ "./src/ImageSpriteFrame.js":
/*!*********************************!*\
  !*** ./src/ImageSpriteFrame.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var SpriteAnimationFrame = __webpack_require__(/*! ../src/SpriteAnimationFrame */ \"./src/SpriteAnimationFrame.js\");\n/** ImageSprite implementation of SpriteAnimationFrame.\n* @extends {SpriteAnimationFrame}\n* @constructor\n* @param {Object} props Properties\n* @param {number} props.duration How long (milliseconds) to display this frame.\n* @param {number} props.sourceX The starting x of the sub-section of the image for this frame.\n* @param {number} props.sourceY The starting y of the sub-section of the image for this frame.\n* @param {number} props.sourceWidth The width of the sub-section of the image for this frame.\n* @param {number} props.sourceHeight The height of the sub-section of the image for this frame.\n*/\n\n\nfunction ImageSpriteFrame(props) {\n  props = props || {};\n  SpriteAnimationFrame.call(this);\n  this._duration = props.duration;\n  this._sx = props.sourceX;\n  this._sy = props.sourceY;\n  this._sWidth = props.sourceWidth;\n  this._sHeight = props.sourceHeight;\n}\n\n;\nImageSpriteFrame.prototype = new SpriteAnimationFrame();\nImageSpriteFrame.prototype.constructor = ImageSpriteFrame;\n/** Return the duration of this frame.\n* @override\n* @returns {number}\n*/\n\nImageSpriteFrame.prototype.getDuration = function () {\n  return this._duration;\n};\n/** Return the starting x point on the source Image for this frame\n* @returns {number}\n*/\n\n\nImageSpriteFrame.prototype.getSourceX = function () {\n  return this._sx;\n};\n/** Return the starting y point on the source Image for this frame\n* @returns {number}\n*/\n\n\nImageSpriteFrame.prototype.getSourceY = function () {\n  return this._sy;\n};\n/** Return the width of the subsection of the source Image for this frame\n* @returns {number}\n*/\n\n\nImageSpriteFrame.prototype.getSourceWidth = function () {\n  return this._sWidth;\n};\n/** Return the height of the subsection of the source Image for this frame\n* @returns {number}\n*/\n\n\nImageSpriteFrame.prototype.getSourceHeight = function () {\n  return this._sHeight;\n};\n\nmodule.exports = ImageSpriteFrame;\n\n//# sourceURL=webpack:///./src/ImageSpriteFrame.js?");

/***/ }),

/***/ "./src/Layer.js":
/*!**********************!*\
  !*** ./src/Layer.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Utils = __webpack_require__(/*! slcommon/src/Utils */ \"./node_modules/slcommon/src/Utils.js\");\n/**\n* Abstract class for graphical layers on a Screen.<br />\n* Existing implementations: {@link BackgroundLayer}, {@link GfxLayer}\n* @constructor\n* @param {Object} props Configuration properties.\n* @param {Screen} props.screenContext The parent screen.\n* @param {CanvasContextWrapper} props.canvasContextWrapper The canvasContextWrapper. This layer will draw to the canvas' context, via wrapper's exposed methods.\n* @param {number} props.width The width of the layer.  Should match Screen.\n* @param {number} props.height The height of the layer.  Should match Screen.\n* @see BackgroundLayer\n* @see GfxLayer\n*/\n\n\nfunction Layer(props) {\n  props = props || {};\n  this._width = props.width || 320;\n  this._height = props.height || 200;\n  this._canvasContextWrapper = props.canvasContextWrapper;\n  this._dirty = true;\n  this._pendingViewOriginX = null;\n  this._pendingViewOriginY = null;\n}\n\n;\n/** Return whether this layer is dirty.  A dirty layer needs to be completely redrawn.\n* @return {boolean}\n*/\n\nLayer.prototype.isDirty = function () {\n  return this._dirty;\n};\n/**\n* Set whether layer is dirty.  If dirty, the layer will be cleared and redrawn during the next render phase.\n* @param {boolean} dirty\n*/\n\n\nLayer.prototype.setDirty = function (dirty) {\n  this._dirty = dirty;\n};\n/** Offset the canvasContextWrapper horizontally by a specified amount.\n* @param {number} viewOriginX The X offset.\n*/\n\n\nLayer.prototype.setViewOriginX = function (viewOriginX) {\n  this._pendingViewOriginX = viewOriginX;\n  if (this._pendingViewOriginX !== null && this._pendingViewOriginX !== this.getViewOriginX()) this.setDirty(true);\n};\n/** Offset the canvasContextWrapper vertically by a specified amount.\n* @param {number} viewOriginY The Y offset.\n*/\n\n\nLayer.prototype.setViewOriginY = function (viewOriginY) {\n  this._pendingViewOriginY = viewOriginY;\n  if (this._pendingViewOriginY !== null && this._pendingViewOriginY !== this.getViewOriginY()) this.setDirty(true);\n};\n/** Return the current x offset of the canvasContextWrapper.\n* @return {number} The x offset.\n*/\n\n\nLayer.prototype.getViewOriginX = function () {\n  return this._canvasContextWrapper.getViewOriginX();\n};\n/** Return the current y offset of the viewport.\n* @return {number} The y offset.\n*/\n\n\nLayer.prototype.getViewOriginY = function () {\n  return this._canvasContextWrapper.getViewOriginY();\n};\n/** @private */\n\n\nLayer.prototype.getPendingViewOriginX = function () {\n  return this._pendingViewOriginX;\n};\n/** @private */\n\n\nLayer.prototype.getPendingViewOriginY = function () {\n  return this._pendingViewOriginY;\n};\n/** Returns the width of the Layer\n* @returns {number}\n*/\n\n\nLayer.prototype.getWidth = function () {\n  return this._width;\n};\n/** Returns the height of the Layer\n* @returns {number}\n*/\n\n\nLayer.prototype.getHeight = function () {\n  return this._height;\n};\n/** Returns the CanvasContextWrapper for this layer.\n* @returns {CanvasContextWrapper}\n*/\n\n\nLayer.prototype.getCanvasContextWrapper = function () {\n  return this._canvasContextWrapper;\n};\n/** Check if image smoothing is enabled for this layer.\n* @return {bool}\n*/\n\n\nLayer.prototype.isImageSmoothingEnabled = function () {\n  return this._canvasContextWrapper.isImageSmoothingEnabled();\n};\n/** Turn image smoothing on or off for this layer.\n* @param {bool} imageSmoothingEnabled\n*/\n\n\nLayer.prototype.setImageSmoothingEnabled = function (imageSmoothingEnabled) {\n  this._canvasContextWrapper.setImageSmoothingEnabled(imageSmoothingEnabled);\n\n  this.setDirty(true);\n};\n/** Update this Layer. <b>Sub-classes MUST implement this method</b>\n* @abstract\n* @param {number} time The current time (milliseconds)\n* @param {number} diff The difference between the last time and the current time  (milliseconds)\n*/\n\n\nLayer.prototype.update = function (time, diff) {};\n/** Render this Layer. <b>Sub-classes MUST implement this method</b>\n* @abstract\n* @param {number} time The current time (milliseconds)\n* @param {number} diff The difference between the last time and the current time  (milliseconds)\n*/\n\n\nLayer.prototype.render = function (time, diff) {};\n/** Execute prerendering activities.  Sub-classes may override this, but should still call the base method.\n* @param {number} time The current time (milliseconds)\n* @param {number} diff The difference between the last time and the current time  (milliseconds)\n*/\n\n\nLayer.prototype.preRender = function (time, diff) {\n  if (this.isDirty()) this.getCanvasContextWrapper().clear();\n\n  if (!Utils.isNullOrUndefined(this.getPendingViewOriginX())) {\n    this.getCanvasContextWrapper().setViewOriginX(this.getPendingViewOriginX());\n    this._pendingViewOriginX = null;\n  }\n\n  if (!Utils.isNullOrUndefined(this.getPendingViewOriginY())) {\n    this.getCanvasContextWrapper().setViewOriginY(this.getPendingViewOriginY());\n    this._pendingViewOriginY = null;\n  }\n};\n/** Execute postrendering activities.  Sub-classes may override this, but should still call the base method.\n* @param {number} time The current time (milliseconds)\n* @param {number} diff The difference between the last time and the current time  (milliseconds)\n*/\n\n\nLayer.prototype.postRender = function (time, diff) {\n  this.setDirty(false);\n};\n/** Propagate a mouse event to this Layer. <b>Sub-classes MUST implement this method</b>\n* @abstract\n* @param {Event} event The mouse event\n*/\n\n\nLayer.prototype.handleMouseEvent = function (event) {};\n/** Clears all contents of this Layer.\n*/\n\n\nLayer.prototype.clearLayer = function () {\n  this._canvasContextWrapper.clearRect(0, 0, this.getWidth(), this.getHeight());\n};\n/** Progressively fade the layer to black.\n* @param {number} amount The percentage to dim the layer; 1 = completely black; 0 = no dim.\n* @param {int} steps The number of stesp to take to reach the fade amount.  More steps = finer progression.\n* @param {int} interval The number of milliseconds to wait between steps.\n*/\n\n\nLayer.prototype.dimLayer = function (amount, steps, interval) {\n  var stepAmount = amount / steps;\n  setTimeout(this._dimStep.bind(this, stepAmount, stepAmount, steps, interval), interval);\n};\n/** @private */\n\n\nLayer.prototype._dimStep = function (amount, stepAmount, steps, interval) {\n  var canvasContext = this.getCanvasContextWrapper();\n  canvasContext.clearRect(0, 0, this.getWidth(), this.getHeight());\n  canvasContext.fillStyle = \"rgba(0,0,0,\" + amount + \")\";\n  canvasContext.fillRect(0, 0, this.getWidth(), this.getHeight());\n\n  if (steps > 0) {\n    setTimeout(this._dimStep.bind(this, amount + stepAmount, stepAmount, steps - 1, interval), interval);\n  }\n};\n\nmodule.exports = Layer;\n\n//# sourceURL=webpack:///./src/Layer.js?");

/***/ }),

/***/ "./src/LayerFactory.js":
/*!*****************************!*\
  !*** ./src/LayerFactory.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Utils = __webpack_require__(/*! ./Utils */ \"./src/Utils.js\");\n\nvar _GfxLayer = __webpack_require__(/*! ./GfxLayer */ \"./src/GfxLayer.js\");\n\nvar _BackgroundLayer = __webpack_require__(/*! ./BackgroundLayer */ \"./src/BackgroundLayer.js\");\n/** Creates Layers.\n* By default, registers functions to create GfxLayer and BackgroundLayer.\n* Additional types can be registered by passing in the registeredTypes parameter.\n* @constructor\n* @param {Object.<string, function>} [registeredTypes={}] An object containing key-value pairs of type name and a function to create the layer type.\n*/\n\n\nfunction LayerFactory(registeredTypes) {\n  registeredTypes = registeredTypes || {};\n  this._registeredTypes = {};\n  Object.keys(LayerFactory.DefaultTypes).forEach(function (key) {\n    this._registeredTypes[key] = LayerFactory.DefaultTypes[key];\n  }.bind(this));\n  Object.keys(registeredTypes).forEach(function (key) {\n    this._registeredTypes[key] = registeredTypes[key];\n  }.bind(this));\n}\n\n;\n/** Creates a layer of a specified type with specified properties.\n* @param {string} type The type of layer to create.\n* @param {Object} layerProps The properties to pass to the l\n*/\n\nLayerFactory.prototype.getLayer = function (type, layerProps) {\n  var layer = null;\n  var ctor = this._registeredTypes[type];\n\n  if (ctor && Utils.isFunction(ctor)) {\n    layer = ctor(layerProps);\n  }\n\n  return layer;\n};\n\nLayerFactory.DefaultTypes = {\n  \"GfxLayer\": function GfxLayer(props) {\n    return new _GfxLayer(props);\n  },\n  \"BackgroundLayer\": function BackgroundLayer(props) {\n    return new _BackgroundLayer(props);\n  }\n};\nmodule.exports = LayerFactory;\n\n//# sourceURL=webpack:///./src/LayerFactory.js?");

/***/ }),

/***/ "./src/MouseEvent.js":
/*!***************************!*\
  !*** ./src/MouseEvent.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Event = __webpack_require__(/*! slcommon/src/Event */ \"./node_modules/slcommon/src/Event.js\");\n/**\n* MouseEvent - mouseup, mousedown, mousemove\n* @constructor\n* @param {EventType} type The type of the event. Refer to EventType (in slcommon).\n* @param {Object} data Data for the event.  Determined by event emitter.\n* @param {time} [time] Optional.  The time the event occurred. If not specified, uses performance.now()\n*/\n\n\nfunction MouseEvent(type, data, time) {\n  Event.call(this, type, data, time);\n  this.endEventPropagation = false;\n}\n\n;\nMouseEvent.prototype = new Event();\nMouseEvent.prototype.constructor = MouseEvent;\nmodule.exports = MouseEvent;\n\n//# sourceURL=webpack:///./src/MouseEvent.js?");

/***/ }),

/***/ "./src/MoveOrder.js":
/*!**************************!*\
  !*** ./src/MoveOrder.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Utils = __webpack_require__(/*! ./Utils */ \"./src/Utils.js\");\n/** Directs movement of {@link GfxElements} when moveTo() is called.\n* These are created and handled internally in GfxElements.\n* @constructor\n* @param {GfxElements} element The element this MoveOrder will be bound to.\n* @param {number} tx The target x location for the element.\n* @param {number} ty The target y location for the element.\n* @param {number} duration The length of time (milliseconds) for the movement to the target location.\n* @param {function} elementCallback The callback of the parent element; called when movement is done.\n* @param {function} [callback] Optional callback to be called when movement is done.\n*/\n\n\nfunction MoveOrder(element, tx, ty, duration, elementCallback, callback) {\n  this._element = element;\n  this._tx = tx;\n  this._ty = ty;\n  this._startX = 0;\n  this._startY = 0;\n  this._duration = duration;\n  this._elementCallback = elementCallback;\n  this._callback = callback;\n  this._end = false;\n  this._started = false;\n  this._startTime = -1;\n}\n\n;\n/** Initialize movement conditions.\n*/\n\nMoveOrder.prototype.start = function () {\n  this._startX = this._element.getX();\n  this._startY = this._element.getY();\n  this._started = true;\n};\n/** Update the position of the parent element, based on time difference from last render cycle, and the time remaining to hit the target location.\n* @param {number} time The current time (milliseconds)\n* @param {number} diff The difference between the last time and the current time  (milliseconds)\n*/\n\n\nMoveOrder.prototype.update = function (time, diff) {\n  if (!this._started) return;\n  if (this._end) return;\n  if (this._startTime === -1) this._startTime = time;\n\n  var timePercent = this._timePercent(time);\n\n  if (timePercent >= 1) {\n    this.end();\n  } else {\n    this._element.setX(this._startX + (this._tx - this._startX) * timePercent);\n\n    this._element.setY(this._startY + (this._ty - this._startY) * timePercent);\n  }\n};\n/** Finish movement and notify the parent element.\n*/\n\n\nMoveOrder.prototype.end = function () {\n  this._end = true;\n\n  this._element.setX(this._tx);\n\n  this._element.setY(this._ty);\n\n  if (Utils.isFunction(this._elementCallback)) this._elementCallback();\n  if (Utils.isFunction(this._callback)) this._callback(this._element);\n};\n/** @private */\n\n\nMoveOrder.prototype._timePercent = function (time) {\n  return (time - this._startTime) / this._duration;\n};\n\nmodule.exports = MoveOrder;\n\n//# sourceURL=webpack:///./src/MoveOrder.js?");

/***/ }),

/***/ "./src/Screen.js":
/*!***********************!*\
  !*** ./src/Screen.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar LayerFactory = __webpack_require__(/*! ./LayerFactory */ \"./src/LayerFactory.js\");\n\nvar Utils = __webpack_require__(/*! ./Utils */ \"./src/Utils.js\");\n\nvar EventType = __webpack_require__(/*! ./EventType */ \"./src/EventType.js\");\n\nvar EventNotifierMixin = __webpack_require__(/*! slcommon/src/EventNotifierMixin */ \"./node_modules/slcommon/src/EventNotifierMixin.js\");\n\nvar CanvasContextWrapper = __webpack_require__(/*! ./CanvasContextWrapper */ \"./src/CanvasContextWrapper.js\");\n\nvar Event = __webpack_require__(/*! slcommon/src/Event */ \"./node_modules/slcommon/src/Event.js\");\n\nvar MouseEvent = __webpack_require__(/*! ./MouseEvent */ \"./src/MouseEvent.js\");\n\nvar _window = Utils.getWindow();\n/** The Screen is the overriding container for Graphics components.\n* The Screen orchestrates updating and rendering its layers, propagates\n* mouse events down to the layers, and notifies event listeners when events occur.\n* @constructor\n* @param {Object} props Properties\n* @param {HTMLElement} props.targetDiv The target HTMLElement into which the screen and its layers will be built.\n* @param {LayerFactory} [props.layerFactory=LayerFactory] The layer factory to use to create layers.  Defaults to LayerFactory.\n* @param {int} [props.scaleX=1] The horizontal scale of the screen.\n* @param {int} [props.scaleY=1] The vertical scale of the screen.\n* @param {int} [props.width=800] The width of the screen.\n* @param {int} [props.height=600] The height of the screen.\n* @param {HTMLElement} [props.fpsElem] Optional. An HTMLElement to write Frames-per-second information to.\n* @param {boolean} [props.imageSmoothingEnabled=false] Whether to use image smoothing on child canvases.\n* @param {boolean} [props.useMouseMoveEvents=true] Whether to listen for mouseevents on this screen.\n* @param {string} [props.backgroundColor=black] Background color of the screen. Any valid CSS color string.\n* @param {string} [props.borderColor=grey] Border color of the screen. Any valid CSS color string.\n* @param {number|string} [props.borderSize=1] The size of the border. If a number\n* is provided, this will be interpretted as pixels, and a uniform border width will be set.\n* If a string is provided it will be interpretted as a CSS string, e.g. \"10px 0px 10px 0px\";\n* @param {function} [props.requestAnimationFrame=window.requestAnimationFrame] A function that regulates render rate.  Uses window.requestAnimationFrame by default.\n*/\n\n\nfunction Screen(props) {\n  props = props || {};\n  this._targetDiv = props.targetDiv;\n  this._layerFactory = props.layerFactory || new LayerFactory();\n  this._scaleX = props.scaleX || 1;\n  this._scaleY = props.scaleY || 1;\n  this._width = (props.width || 640) * this._scaleX;\n  this._height = (props.height || 480) * this._scaleY;\n  this._fpsElem = props.fpsElem || null;\n  this._imageSmoothingEnabled = props.imageSmoothingEnabled || false;\n  this._avgTime = 0;\n  this._last = 0;\n  this._mouseX = -1;\n  this._mouseY = -1;\n  this._mouseMoved = false;\n  this._paused = false;\n  this._unpaused = false;\n  this._useMouseMoveEvents = Utils.isNullOrUndefined(props.useMouseMoveEvents) ? true : props.useMouseMoveEvents;\n  this._backgroundColor = props.backgroundColor || \"black\";\n  this._borderColor = props.borderColor || \"grey\";\n\n  this._setBorderSize(props.borderSize || 1);\n\n  this._fpsMonitorArray = [];\n  this._fpsMonitorIndex = 0;\n  this._viewOriginX = 0;\n  this._viewOriginY = 0;\n  this._pendingViewOriginX = null;\n  this._pendingViewOriginY = null;\n  this._layers = [];\n  this._requestAnimationFrame = props.requestAnimationFrame || (_window.requestAnimationFrame ? _window.requestAnimationFrame.bind(_window) : function () {});\n  this.EventNotifierMixinInitializer();\n}\n\n;\nEventNotifierMixin.call(Screen.prototype);\nScreen.mockDocument = {\n  addEventListener: function addEventListener() {},\n  createElement: function createElement() {\n    return {\n      style: {},\n      getContext: function getContext() {\n        return {};\n      }\n    };\n  },\n  hidden: false\n};\nScreen.document = _window.document || Screen.mockDocument;\n/** Setup the screen on the page. Must be called prior to rendering.\n*/\n\nScreen.prototype.initialize = function () {\n  this._prepareDiv();\n\n  this._setupEventListeners();\n};\n\nScreen.prototype._setBorderSize = function (border) {\n  if (typeof border === \"number\") {\n    this._borderSize = border + \"px\";\n  } else {\n    this._borderSize = border;\n  }\n};\n/** Offset child layers horizontally by a specified amount.\n* @param {number} viewOriginX The x coordinate for the offset.\n*/\n\n\nScreen.prototype.setViewOriginX = function (viewOriginX) {\n  this._pendingViewOriginX = viewOriginX;\n\n  if (this._pendingViewOriginX !== null && this._pendingViewOriginX !== this.getViewOriginX()) {\n    this.getLayers().forEach(function (layer) {\n      layer.setViewOriginX(viewOriginX);\n    });\n  }\n};\n/** Offset child layers vertically by a specified amount.\n* @param {number} viewOriginY The y coordinate for the offset.\n*/\n\n\nScreen.prototype.setViewOriginY = function (viewOriginY) {\n  this._pendingViewOriginY = viewOriginY;\n\n  if (this._pendingViewOriginY !== null && this._pendingViewOriginY !== this.getViewOriginY()) {\n    this.getLayers().forEach(function (layer) {\n      layer.setViewOriginY(viewOriginY);\n    });\n  }\n};\n/** Get the current horizontal layer offset\n* @return {number}\n*/\n\n\nScreen.prototype.getViewOriginX = function () {\n  return this._viewOriginX;\n};\n/** Get the current vertical layer offset\n* @return {number}\n*/\n\n\nScreen.prototype.getViewOriginY = function () {\n  return this._viewOriginY;\n};\n/** @private */\n\n\nScreen.prototype.getPendingViewOriginX = function () {\n  return this._pendingViewOriginX;\n};\n/** @private */\n\n\nScreen.prototype.getPendingViewOriginY = function () {\n  return this._pendingViewOriginY;\n};\n/** @private */\n\n\nScreen.prototype._prepareDiv = function () {\n  this._targetDiv.style.width = this._width;\n  this._targetDiv.style.height = this._height;\n  this._targetDiv.style.backgroundColor = this._backgroundColor;\n  this._targetDiv.style.border = this._borderSize + \" solid \" + this._borderColor;\n};\n/** @private */\n\n\nScreen.prototype._setupEventListeners = function () {\n  this._targetDiv.addEventListener(\"mouseup\", this.handleMouseEvent.bind(this), true);\n\n  this._targetDiv.addEventListener(\"mousedown\", this.handleMouseEvent.bind(this), true);\n\n  if (this._useMouseMoveEvents) this._targetDiv.addEventListener(\"mousemove\", this.handleMouseMoveEvent.bind(this), true);\n  Screen.document.addEventListener(\"visibilitychange\", this.handleVisibilityChange.bind(this), false);\n};\n/** @private */\n\n\nScreen.prototype.handleVisibilityChange = function () {\n  this._tabNotVisible = Screen.document.hidden;\n\n  if (!this._tabNotVisible && !this._paused) {\n    this._unpaused = true;\n\n    this._requestAnimationFrame(this.render.bind(this));\n  }\n};\n/** Add an event listener to the document.\n* @param {string} event The type of event.\n* @param {Function} listener The function to call when the event occurs.\n*/\n\n\nScreen.prototype.addEventListenerToDocument = function (event, listener) {\n  Screen.document.addEventListener(event, listener);\n};\n/** Set the background color.\n* @param {string} color Any valid CSS color string.\n*/\n\n\nScreen.prototype.setBackgroundColor = function (color) {\n  this._backgroundColor = color;\n  this._targetDiv.style.backgroundColor = color;\n};\n/** Return the current backgroundColor.\n* @returns {string}\n*/\n\n\nScreen.prototype.getBackgroundColor = function (color) {\n  return this._backgroundColor;\n};\n/** Set the border color.\n* @param {string} color Any valid CSS color string.\n*/\n\n\nScreen.prototype.setBorderColor = function (color) {\n  this._borderColor = color;\n  this._targetDiv.style.borderColor = color;\n};\n/** Return the current border color.\n* @returns {string}\n*/\n\n\nScreen.prototype.getBorderColor = function () {\n  return this._borderColor;\n};\n/** Set the border size.\n* @param {int|string} size The size for the border.  If a number\n* is provided, this will be interpretted as pixels, and a uniform border width will be set.\n* If a string is provided it will be interpretted as a CSS string, e.g. \"10px 0px 10px 0px\";\n*/\n\n\nScreen.prototype.setBorderSize = function (size) {\n  this._setBorderSize(size);\n\n  this._targetDiv.style.borderWidth = this._borderSize;\n};\n/** Return the current border size.\n* @returns {int}\n*/\n\n\nScreen.prototype.getBorderSize = function () {\n  return this._targetDiv.style.borderWidth;\n};\n/** Return the current top border size.\n* @returns {int}\n*/\n\n\nScreen.prototype.getBorderTopSize = function () {\n  return this._targetDiv.style.borderTopWidth;\n};\n/** Return the current left border size.\n* @returns {int}\n*/\n\n\nScreen.prototype.getBorderLeftSize = function () {\n  return this._targetDiv.style.borderLeftWidth;\n};\n/** Return the current right border size.\n* @returns {int}\n*/\n\n\nScreen.prototype.getBorderRightSize = function () {\n  return this._targetDiv.style.borderRightWidth;\n};\n/** Return the current bottom border size.\n* @returns {int}\n*/\n\n\nScreen.prototype.getBorderBottomSize = function () {\n  return this._targetDiv.style.borderBottomWidth;\n};\n/** Return the width.\n* @returns {int}\n*/\n\n\nScreen.prototype.getWidth = function () {\n  return this._width;\n};\n/** Return the height.\n* @returns {int}\n*/\n\n\nScreen.prototype.getHeight = function () {\n  return this._height;\n};\n/** Return the x-scale.\n* @returns {int}\n*/\n\n\nScreen.prototype.getScaleX = function () {\n  return this._scaleX;\n};\n/** Return the y-scale.\n* @returns {int}\n*/\n\n\nScreen.prototype.getScaleY = function () {\n  return this._scaleY;\n};\n/** Return the current x coordinate of the mouse.\n* @returns {int}\n*/\n\n\nScreen.prototype.getMouseX = function () {\n  return this._mouseX;\n};\n/** Return the current y coordinate of the mouse.\n* @returns {int}\n*/\n\n\nScreen.prototype.getMouseY = function () {\n  return this._mouseY;\n};\n/** Return whether image smoothing is enabled on this screent.\n* @return {boolean}\n*/\n\n\nScreen.prototype.isImageSmoothingEnabled = function () {\n  return this._imageSmoothingEnabled;\n};\n/** Turn image smoothing on or off for this layer.\n* @param {bool} imageSmoothingEnabled\n*/\n\n\nScreen.prototype.setImageSmoothingEnabled = function (imageSmoothingEnabled) {\n  this._imageSmoothingEnabled = imageSmoothingEnabled;\n};\n/** Create a new {@link Layer} and add it to this screen.  Layers will be rendered in FIFO order,\n* so layers added later will be drawn on top of layers added earlier.\n* @param {string} type The type of layer to add - either \"BackgroundLayer\" or \"GfxLayer\"\n* @see Layer\n*/\n\n\nScreen.prototype.createLayer = function (type, props) {\n  props = props || {};\n  var canvas = this.createCanvasForLayer();\n  var canvasContextWrapper = this.createCanvasContextWrapper(canvas);\n\n  var layerProps = _objectSpread({}, props);\n\n  layerProps.width = layerProps.width || this.getWidth();\n  layerProps.height = layerProps.height || this.getHeight();\n  layerProps.canvasContextWrapper = canvasContextWrapper;\n\n  var layer = this._layerFactory.getLayer(type, layerProps);\n\n  this.addLayer(layer);\n  return layer;\n};\n/** @private */\n\n\nScreen.prototype.createCanvasForLayer = function () {\n  var canvas = Screen.document.createElement(\"CANVAS\");\n\n  this._targetDiv.appendChild(canvas);\n\n  canvas.width = this._width;\n  canvas.height = this._height;\n  canvas.style.position = \"absolute\";\n  return canvas;\n};\n/** @private */\n\n\nScreen.prototype.createCanvasContextWrapper = function (canvas) {\n  return new CanvasContextWrapper({\n    canvasContext: canvas.getContext(\"2d\"),\n    imageSmoothingEnabled: this._imageSmoothingEnabled,\n    width: this._width,\n    height: this._height\n  });\n};\n/** Add a new  {@link Layer} to this screen.  The preferred method of adding layers\n* is via the createLayer() method, but this will also work.\n* Layers will be rendered in FIFO order,\n* so layers added later will be drawn on top of layers added earlier.\n* @param {Layer} layer The layer to add to the screen.\n* @see Layer\n*/\n\n\nScreen.prototype.addLayer = function (layer) {\n  this._layers.push(layer);\n};\n/** Return the array of layers.\n* @returns {Array}\n*/\n\n\nScreen.prototype.getLayers = function () {\n  return this._layers;\n};\n/** Pause or unpause the screen.\n* @param {boolean} boolean true = pause the screen; false = unpause the screen.\n* @fires Screen#SCREEN_PAUSED\n* @fires Screen#SCREEN_RESUMED\n*/\n\n\nScreen.prototype.setPaused = function (_boolean) {\n  if (this._paused && !_boolean) this._unpaused = true;\n  this._paused = _boolean;\n  this.notify(new Event(this._paused ? EventType.SCREEN_PAUSED : EventType.SCREEN_RESUMED));\n  if (!this._paused) this._requestAnimationFrame(this.render.bind(this));\n};\n/** Add a one-time event handler for the start of the next frame.\n* @param {Function} callback The handler function.\n* @returns {String} The Id assigned to the handler function.\n*/\n\n\nScreen.prototype.onNextFrameBegin = function (callback) {\n  return this.on(EventType.NEXT_FRAME_BEGIN, callback);\n};\n/** Add a one-time event handler for the end of the next frame.\n* @param {Function} callback The handler function.\n* @returns {String} The Id assigned to the handler function.\n*/\n\n\nScreen.prototype.onNextFrameEnd = function (callback) {\n  return this.on(EventType.NEXT_FRAME_END, callback);\n};\n/** @private */\n\n\nScreen.prototype._doBeforeRenderEvents = function (time, diff) {\n  this.notify(new Event(EventType.NEXT_FRAME_BEGIN, {\n    diff: diff\n  }, time));\n  this.clearEventHandlers(EventType.NEXT_FRAME_BEGIN);\n  this.notify(new Event(EventType.BEFORE_RENDER, {\n    diff: diff\n  }, time));\n};\n/** @private */\n\n\nScreen.prototype._doAfterRenderEvents = function (time, diff) {\n  this.notify(new Event(EventType.NEXT_FRAME_END, {\n    diff: diff\n  }, time));\n  this.clearEventHandlers(EventType.NEXT_FRAME_END);\n  this.notify(new Event(EventType.AFTER_RENDER, {\n    diff: diff\n  }, time));\n};\n/** Return whether the screen is paused\n* @returns {boolean}\n*/\n\n\nScreen.prototype.isPaused = function () {\n  return this._paused;\n};\n/** Render the screen and all layers.\n* @param {number} time The current time in milliseconds.\n* @fires Screen#NEXT_FRAME_BEGIN\n* @fires Screen#NEXT_FRAME_END\n* @fires Screen#BEFORE_RENDER\n* @fires Screen#AFTER_RENDER\n* @fires Screen#MOUSE_MOVE\n*/\n\n\nScreen.prototype.render = function (time) {\n  time = time || 1;\n  if (this._paused || this._tabNotVisible) return;\n\n  if (this._unpaused) {\n    this._unpaused = false;\n    this._last = Math.floor(time) - 1;\n  }\n\n  time = Math.floor(time);\n  var elapsed = Date.now();\n  var diff = time - this._last;\n  this._last = time;\n\n  if (this._mouseMoved) {\n    this._handleMouseMoveEvent(time);\n  }\n\n  this._doBeforeRenderEvents(time, diff);\n\n  this._updateFps(diff);\n\n  this._update(time, diff);\n\n  this._render(time, diff);\n\n  this._updateViewOrigins();\n\n  this._doAfterRenderEvents(time, diff);\n\n  elapsed = Date.now() - elapsed;\n  if (this._fpsElem && this._fpsMonitorIndex === 0) this._fpsElem.innerHTML += \"<br />Avg MS per frame: \" + elapsed;\n\n  this._requestAnimationFrame(this.render.bind(this));\n};\n/** @private */\n\n\nScreen.prototype._updateViewOrigins = function () {\n  if (!Utils.isNullOrUndefined(this.getPendingViewOriginX())) {\n    this._viewOriginX = this.getPendingViewOriginX();\n    this._pendingViewOriginX = null;\n  }\n\n  if (!Utils.isNullOrUndefined(this.getPendingViewOriginY())) {\n    this._viewOriginY = this.getPendingViewOriginY();\n    this._pendingViewOriginY = null;\n  }\n};\n/** @private */\n\n\nScreen.prototype._handleMouseMoveEvent = function (time) {\n  var coordinateData = this._getCoordinateDataForMouseEvent(this._mouseX, this._mouseY);\n\n  var event = new MouseEvent(EventType.MOUSE_MOVE, coordinateData, time);\n  this.propagateMouseEventThroughLayers(event);\n  if (!event.endEventPropagation) this.notify(event);\n  this._mouseMoved = false;\n};\n/** @private */\n\n\nScreen.prototype._updateFps = function (diff) {\n  if (this._fpsElem) {\n    var fps = Math.floor(1000 / diff);\n\n    if (this._fpsMonitorArray.length < 30) {\n      this._fpsMonitorArray.push(fps);\n    } else {\n      this._fpsMonitorArray[this._fpsMonitorIndex] = fps;\n    }\n\n    this._fpsMonitorIndex++;\n    if (this._fpsMonitorIndex >= 30) this._fpsMonitorIndex = 0;\n    var fpsa = 1;\n\n    for (var i = 0; i < this._fpsMonitorArray.length; i++) {\n      fpsa += this._fpsMonitorArray[i] / 30;\n    }\n\n    if (this._fpsElem && this._fpsMonitorIndex === 0) this._fpsElem.innerHTML = \"fps: \" + Math.floor(fpsa);\n  }\n};\n/** @private */\n\n\nScreen.prototype._update = function (time, diff) {\n  for (var i = 0; i < this._layers.length; i++) {\n    this._layers[i].update(time, diff);\n  }\n};\n/** @private */\n\n\nScreen.prototype._render = function (time, diff) {\n  for (var i = 0; i < this._layers.length; i++) {\n    this._layers[i].preRender(time, diff);\n\n    this._layers[i].render(time, diff);\n\n    this._layers[i].postRender(time, diff);\n  }\n};\n/** Handle a mouse move event.  This does not directly propagate the event to\n* layers and elements; rather it will flag that a mouse movement has occured, and records its current location.\n* The event will be propagated during the next render cycle.\n* @param {Event} e The mouse event\n*/\n\n\nScreen.prototype.handleMouseMoveEvent = function (e) {\n  if (this._paused) return false;\n  this._mouseMoved = true;\n  var x = this.getXFromMouseEvent(e);\n  var y = this.getYFromMouseEvent(e);\n\n  if (x < 0 || x >= this._width || y < 0 || y >= this._height) {\n    this._mouseX = -1;\n    this._mouseY = -1;\n    return false;\n  }\n\n  this._mouseX = x;\n  this._mouseY = y;\n};\n/** @private */\n\n\nScreen.prototype._getCoordinateDataForMouseEvent = function (canvasX, canvasY) {\n  var viewOriginAdjustedX = this.getViewOriginAdjustedX(canvasX);\n  var viewOriginAdjustedY = this.getViewOriginAdjustedY(canvasY);\n  var x = this.getUnScaledX(viewOriginAdjustedX);\n  var y = this.getUnScaledY(viewOriginAdjustedY);\n  var data = {\n    x: x,\n    y: y,\n    viewOriginAdjustedX: viewOriginAdjustedX,\n    viewOriginAdjustedY: viewOriginAdjustedY,\n    rawX: canvasX,\n    rawY: canvasY\n  };\n  return data;\n};\n/** Handles mouse up and mouse down events; notifies any local handlers and propagates the event to all layers.\n* @param {Event} e The mouse event\n* @fires Screen#MOUSE_UP\n* @fires Screen#MOUSE_DOWN\n*/\n\n\nScreen.prototype.handleMouseEvent = function (e) {\n  if (this._paused) return false;\n  var canvasX = this.getXFromMouseEvent(e);\n  var canvasY = this.getYFromMouseEvent(e);\n\n  if (canvasX < 0 || canvasX >= this._width || canvasY < 0 || canvasY >= this._height) {\n    return false;\n  }\n\n  var data = this._getCoordinateDataForMouseEvent(canvasX, canvasY);\n\n  data.baseEvent = e;\n  var type = e.type === \"mouseup\" ? EventType.MOUSE_UP : EventType.MOUSE_DOWN;\n  var event = new MouseEvent(type, data); // propagate through layers\n\n  this.propagateMouseEventThroughLayers(event);\n  if (!event.endEventPropagation) this.notify(event);\n  if (e.button === 1) return false;\n};\n/** @private */\n\n\nScreen.prototype.propagateMouseEventThroughLayers = function (event) {\n  for (var i = this._layers.length - 1; i >= 0; i--) {\n    if (event.endEventPropagation) return;\n\n    this._layers[i].handleMouseEvent(event);\n  }\n};\n/** Return the x coordinate from a mouse event.  Accounts for screen position.\n* @param {Event} e Mouse Event\n*/\n\n\nScreen.prototype.getXFromMouseEvent = function (e) {\n  return e.pageX - (this._targetDiv.offsetLeft + parseInt(this.getBorderLeftSize()));\n};\n/** Return the y coordinate from a mouse event.  Accounts for screen position.\n* @param {Event} e Mouse Event\n*/\n\n\nScreen.prototype.getYFromMouseEvent = function (e) {\n  return e.pageY - (this._targetDiv.offsetTop + parseInt(this.getBorderTopSize()));\n};\n/** Return an x value with scale removed.\n* @param {int} x The x coordinate.\n* @return {int} The unscaled x.\n*/\n\n\nScreen.prototype.getUnScaledX = function (x) {\n  return Math.floor(x / this.getScaleX());\n};\n/** Return a y value with scale removed.\n* @param {int} y The y coordinate.\n* @return {int} The unscaled y.\n*/\n\n\nScreen.prototype.getUnScaledY = function (y) {\n  return Math.floor(y / this.getScaleY());\n};\n/** Return an x value adjusted for view origin.\n* @param {int} x The x coordinate.\n* @return {int} The view origin adjusted x.\n*/\n\n\nScreen.prototype.getViewOriginAdjustedX = function (x) {\n  return x - this.getViewOriginX();\n};\n/** Return a y value adjusted for view origin.\n* @param {int} y The y coordinate.\n* @return {int} The view origin adjusted y.\n*/\n\n\nScreen.prototype.getViewOriginAdjustedY = function (y) {\n  return y - this.getViewOriginY();\n};\n/** Directly set the border style.\n* NOTE: subsequent changes using the setBorderColor or setBorderSize methods will overwrite any changes made in this method.\n* @param {string} width Any valid CSS Border width string.\n* @param {string} style Any valid CSS Border style string.\n* @param {string} color Any valid CSS Border color string.\n*/\n\n\nScreen.prototype.setBorder = function (width, style, color) {\n  this._targetDiv.style.borderWidth = width;\n  this._targetDiv.style.borderStyle = style;\n  this._targetDiv.style.borderColor = color;\n};\n\nmodule.exports = Screen;\n/** The screen was paused.\n* @event Screen#SCREEN_PAUSED\n* @property {string} type EventType\n* @property {number} time The time the event was fired.\n*/\n\n/** The screen was unpaused.\n* @event Screen#SCREEN_RESUMED\n* @property {string} type EventType\n* @property {number} time The time the event was fired.\n*/\n\n/** Mouse button down on the screen.\n* @event Screen#MOUSE_DOWN\n* @type {ScreenMouseEvent}\n*/\n\n/** Mouse button up on the screen.\n* @event Screen#MOUSE_UP\n* @type {ScreenMouseEvent}\n*/\n\n/** Mouse moves inside the screen area.\n* @event Screen#MOUSE_MOVE\n* @type {ScreenMouseEvent}\n*/\n\n/** The screen is about to render.\n* @event Screen#BEFORE_RENDER\n* @type {ScreenRenderEvent}\n*/\n\n/** The screen just finished rendering.\n* @event Screen#AFTER_RENDER\n* @type {ScreenRenderEvent}\n*/\n\n/** The screen is about to render. (One time occurance.)\n* @event Screen#NEXT_FRAME_BEGIN\n* @type {ScreenRenderEvent}\n*/\n\n/** The screen just finished rendering. (One time occurance.)\n* @event Screen#NEXT_FRAME_END\n* @type {ScreenRenderEvent}\n*/\n\n//# sourceURL=webpack:///./src/Screen.js?");

/***/ }),

/***/ "./src/Sprite.js":
/*!***********************!*\
  !*** ./src/Sprite.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var GfxElement = __webpack_require__(/*! ./GfxElement */ \"./src/GfxElement.js\");\n\nvar EventType = __webpack_require__(/*! ./EventType */ \"./src/EventType.js\");\n\nvar Event = __webpack_require__(/*! slcommon/src/Event */ \"./node_modules/slcommon/src/Event.js\");\n/** Base element for displaying animations.<br />\n\n* <p>Animation is provided through an array of frames.  Each frame will be shown for a specified duration; after that duration, the next frame is shown.\n* Animation can be looped, or terminated.</p>\n* <p>Animation lifetime of a Sprite can be controlled through the parameters, ttl (Time-to-live), loop (boolean, loop or not), and Loops-to-Live.\n* If any of these parameters causes the Sprite's animation to stop, an event, EventType.SPRITE_ANIMATION_DONE, will be emitted. </p>\n* <p>Note that if the animation stops, the sprite itself will remain on screen; if no longer needed, it must be explicitly hidden or removed.</p>\n* <p>This is an abstract class; you must provide an implementation that overrides renderFrame(), and AnimationFrames that describe what should be rendered.</p>\n* Current Implementations: {@link ImageSprite}\n* @constructor\n* @augments GfxElement\n* @param {Object} props Properties for this GfxElement.\n* @param {Screen} props.screenContext The target screen.\n* @param {int} [props.scaleX=1] Horizontal scale of this element.  Independent of screen scale.\n* @param {int} [props.scaleY=1] Vertical scale of this element.  Independent of screen scale.\n* @param {boolean} [props.hidden=false] Whether to hide this element.\n* @param {number} [props.x=0] The X coordinate for this element.\n* @param {number} [props.y=0] The Y coordinate for this element.\n* @param {number} props.width The width of this element.\n* @param {number} props.height The height this element.\n* @param {number} [props.rotation=0] The amount of rotation to apply to the element, in radians.  Applied on top of base rotation.\n* @param {number} [props.baseRotation=0] The amount of base rotation to apply to the element, in radians. Usually used to apply an initial, unchanging rotation to the element.  Useful for correcting orientation of images.\n* @param {boolean} [props.horizontalFlip=false] Whether to flip the element horizontally.\n* @param {boolean} [props.verticalFlip=false] Whether to flip the element vertically.\n* @param {number} [props.zIndex=-1] The z-index; elements with higher zIndex values will be drawn later than those with lower values (drawn on top of those with lower values).\n* @param {Array} [props.frames=[]] Optional. An array of AnimationFrame's. Default: empty array.\n* @param {number} [props.ttl=-1] Time-to-live.  The time (milliseconds) to continue the Sprites animation.  Default: -1 (unlimited time)\n* @param {boolean} [props.loop=true] Whether to loop the animation or not.\n* @param {int} [props.loopsToLive=-1] If loop is true, the number of loops to execute.  Default: -1 (unlimited loops)\n* @param {int} [props.freezeFrameIdx=-1] When animation completes, switch to the frame indicated by the freeze frame index (referring to the index of the frame in the frames array). Default: -1 (don't change frames when animation stops, stay with the final frame)\n* @see GfxElement\n* @see AnimationFrame\n* @see ImageSprite\n*/\n\n\nfunction Sprite(props) {\n  props = props || {};\n  GfxElement.call(this, props);\n  this._frames = props.frames || [];\n  this._ttl = props.ttl || -1;\n  this._loop = props.loop === false ? false : true;\n  this._loopsToLive = props.loopsToLive || -1;\n  this._freezeFrameIdx = props.freezeFrameIdx || -1;\n  this._fidx = 0;\n  this._currentFrameElapsed = 0;\n  this._done = false;\n  this._loopCount = 0;\n  this._elapsed = 0;\n}\n\n;\nSprite.prototype = new GfxElement();\nSprite.prototype.constructor = Sprite;\n/** Returns the frames for this Sprite.\n* @returns {Array}\n*/\n\nSprite.prototype.getFrames = function () {\n  return this._frames;\n};\n/** Sets the frames for this Sprite.\n* @param {Array} frames\n*/\n\n\nSprite.prototype.setFrames = function (frames) {\n  this._frames = frames;\n};\n/** Adds a frame to this Sprite's frame array.\n* @param {AnimationFrame} frame\n*/\n\n\nSprite.prototype.addFrame = function (frame) {\n  this._frames.push(frame);\n};\n/** Returns this Sprite's Time-to-Live (milliseconds) for animation.\n* @returns {number}\n*/\n\n\nSprite.prototype.getTtl = function () {\n  return this._ttl;\n};\n/** Sets this Sprite's Time-to-Live (milliseconds) for animation.\n* @param {number} ttl\n*/\n\n\nSprite.prototype.setTtl = function (ttl) {\n  this._ttl = ttl;\n};\n/** Returns whether this Sprite is set to loop.\n* @returns {boolean}\n*/\n\n\nSprite.prototype.doesLoop = function () {\n  return this._loop;\n};\n/** Set whether this Sprite should loop.\n* @param {boolean} loop\n*/\n\n\nSprite.prototype.setDoLoop = function (loop) {\n  this._loop = loop;\n};\n/** Returns the number of times this Sprite will loop.\n* @returns {int}\n*/\n\n\nSprite.prototype.getLoopsToLive = function () {\n  return this._loopsToLive;\n};\n/** Sets the number of times this Sprite will loop.\n* @param {int} loopsToLive\n*/\n\n\nSprite.prototype.setLoopsToLive = function (loopsToLive) {\n  this._loopsToLive = loopsToLive;\n};\n/** Returns whether this Sprite has completed all animation loops.\n* @returns {boolean}\n*/\n\n\nSprite.prototype.isDone = function () {\n  return this._done;\n};\n/** Set whether this Sprite is done.  If done, will immediately emit event: EventType.SPRITE_ANIMATION_DONE\n* @param {boolean} done\n*/\n\n\nSprite.prototype.setDone = function (done) {\n  this._done = done;\n  if (done) this.doEndOfAnimation();\n};\n/** Returns the freeze frame index for this Sprite\n* @returns {int}\n*/\n\n\nSprite.prototype.getFreezeFrameIndex = function () {\n  return this._freezeFrameIdx;\n};\n/** Sets the freeze frame index for this Sprite.\n* @param {int} idx\n*/\n\n\nSprite.prototype.setFreezeFrameIndex = function (idx) {\n  this._freezeFrameIdx = idx;\n};\n/** Returns the current number of times the Sprite has looped.\n* @returns {int}\n*/\n\n\nSprite.prototype.getLoopCount = function () {\n  return this._loopCount;\n};\n/** Returns the current frame index.\n* @returns {int}\n*/\n\n\nSprite.prototype.getCurrentFrameIndex = function () {\n  return this._fidx;\n};\n/** Manually sets the current frame index.\n* @param {int} idx\n*/\n\n\nSprite.prototype.setCurrentFrameIndex = function (idx) {\n  this._fidx = idx;\n  this.setDirty(true);\n};\n/** Resets the Sprite state - This will restart the Sprite animation if it stopped.\n*/\n\n\nSprite.prototype.reset = function () {\n  this.setCurrentFrameIndex(0);\n  this._currentFrameElapsed = 0;\n  this._done = false;\n  this._loopCount = 0;\n  this._elapsed = 0;\n  this.setDirty(true);\n};\n/** Updates the state of the Sprite, if necessary.\n* @param {number} time The current time (milliseconds).\n* @param {number} diff The difference between the previous render cycle and the current cycle (milliseconds).\n* @return {Sprite} Returns this element if it needs to be redrawn, null otherwise.\n* @fires Sprite#SPRITE_ANIMATION_DONE Fired if this Sprite stopped animating.\n*/\n\n\nSprite.prototype.update = function (time, diff) {\n  GfxElement.prototype.update.call(this, time, diff);\n  if (this._frames.length === 0 || this._done) return null;\n\n  this._updateTtl(diff);\n\n  this._updateFrame(diff);\n\n  if (this._done) {\n    this.doEndOfAnimation();\n  }\n\n  if (this.isDirty()) return this;\n  return null;\n};\n/** @private */\n\n\nSprite.prototype._updateFrame = function (diff) {\n  this._currentFrameElapsed += diff;\n\n  if (this._currentFrameElapsed >= this._frames[this._fidx].getDuration()) {\n    while (this._currentFrameElapsed >= this._frames[this._fidx].getDuration()) {\n      this._currentFrameElapsed -= this._frames[this._fidx].getDuration();\n      this._fidx++;\n\n      if (this._fidx === this._frames.length) {\n        this._fidx = 0;\n        this._loopCount++;\n\n        if (!this._loop) {\n          this._done = true;\n          if (this._freezeFrameIdx > -1) this._fidx = this._freezeFrameIdx;\n        } else if (this._loopsToLive > -1 && this._loopCount >= this._loopsToLive) {\n          this._done = true;\n        }\n      }\n    }\n\n    this.setDirty(true);\n  }\n};\n/** @private */\n\n\nSprite.prototype._updateTtl = function (diff) {\n  if (this._ttl > -1) {\n    this._elapsed += diff;\n\n    if (this._elapsed >= this._ttl) {\n      this._done = true;\n    }\n  }\n};\n/** Render the current frame of the sprite, if the Sprite is dirty.\n* @param {number} time The current time (milliseconds).\n* @param {number} diff The difference between the previous render cycle and the current cycle (milliseconds).\n*/\n\n\nSprite.prototype.render = function (canvasContext, time, diff) {\n  this.renderFrame(canvasContext, time, diff, this._frames[this._fidx]);\n};\n/** Render the specified AnimationFrame.  <br />\n* <b>Sub-classes MUST implement this method. </b>\n* @abstract\n* @param {number} time The current time (milliseconds).\n* @param {number} diff The difference between the previous render cycle and the current cycle (milliseconds).\n* @param {AnimationFrame} frame The frame to be rendered.\n*/\n\n\nSprite.prototype.renderFrame = function (time, diff, frame) {};\n/** @private */\n\n\nSprite.prototype.doEndOfAnimation = function () {\n  var event = new Event(EventType.SPRITE_ANIMATION_DONE, {\n    element: this\n  });\n  this.notify(event);\n};\n\nmodule.exports = Sprite;\n/** When a sprite completes its animation.\n* @event Sprite#SPRITE_ANIMATION_DONE\n* @property {string} type EventType\n* @property {Object} data The data provided by the event emitter.\n* @property {Sprite} data.element The sprite that stopped animating.\n* @property {number} time The time the event was fired.\n*/\n\n//# sourceURL=webpack:///./src/Sprite.js?");

/***/ }),

/***/ "./src/SpriteAnimationFrame.js":
/*!*************************************!*\
  !*** ./src/SpriteAnimationFrame.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n* Animation frame interface used by sprites.\n* These are intended to be lightweight, and purpose built for the type of Sprite.\n* @interface AnimationFrame\n* @see ImageSprite\n*/\nfunction AnimationFrame() {}\n\n;\n/** Return the duration to display this frame.\n* @returns {number}\n*/\n\nAnimationFrame.prototype.getDuration = function () {\n  throw new Error(\"getDuration Not Implemented on this AnimationFrame\");\n};\n\nmodule.exports = AnimationFrame;\n\n//# sourceURL=webpack:///./src/SpriteAnimationFrame.js?");

/***/ }),

/***/ "./src/Utils.js":
/*!**********************!*\
  !*** ./src/Utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Utils = __webpack_require__(/*! slcommon/src/Utils */ \"./node_modules/slcommon/src/Utils.js\");\n/** Performs some translation on the canvas context before applying some rendering function.\n * @param  {CanvasContextWrapper} context The canvas context wrapper\n * @param  {number} x                The horizontal position to translate the canvas to.\n * @param  {number} y                The vertical position to translate the canvas to.\n * @param  {boolean} flipHorizontally Whether to horizontally flip the canvas.\n * @param  {boolean} flipVertically   Whether to vertically flip the canvas.\n * @param  {number} rotation         The amount to rotate the canvas, in radians.\n * @param  {function} renderCallback   The function to call to perform rendering.\n */\n\n\nUtils.renderWithTranslation = function (context, x, y, flipHorizontally, flipVertically, rotation, renderCallback) {\n  context.save();\n  Utils.translateCanvasContext(context, x, y, flipHorizontally, flipVertically, rotation);\n  renderCallback();\n  context.restore();\n};\n/** Translate a canvas context.\n * @param  {CanvasContextWrapper} context The canvas context wrapper\n * @param  {number} x                The horizontal position to translate the canvas to.\n * @param  {number} y                The vertical position to translate the canvas to.\n * @param  {boolean} flipHorizontally Whether to horizontally flip the canvas.\n * @param  {boolean} flipVertically   Whether to vertically flip the canvas.\n * @param  {number} rotation         The amount to rotate the canvas, in radians.\n */\n\n\nUtils.translateCanvasContext = function (context, x, y, flipHorizontally, flipVertically, rotation) {\n  context.translate(x, y);\n\n  if (flipHorizontally || flipVertically) {\n    context.scale(flipHorizontally ? -1 : 1, flipVertically ? -1 : 1);\n  }\n\n  if (rotation) {\n    context.rotate(rotation);\n  }\n};\n/** Clear the visible portion of a canvas context.\n* @param {CanvasContextWrapper} context\n*/\n\n\nUtils.clearCanvasContext = function (context) {\n  context.clearRect(0, 0, context.canvas.width, context.canvas.height);\n};\n\nUtils.getWindow = function () {\n  if (typeof window !== 'undefined' && window) {\n    return window;\n  } else {\n    return {};\n  }\n};\n\nmodule.exports = Utils;\n\n//# sourceURL=webpack:///./src/Utils.js?");

/***/ })

/******/ });
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: GfxLayer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: GfxLayer.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var UniquePriorityQueue = require("slcommon/src/UniquePriorityQueue");
var Utils = require("slcommon/src/Utils");
var Event = require("slcommon/src/Event");
var EventType = require("../src/EventType");
var Layer = require("./Layer");

/** Graphics layer.
* Generally, the use of Screen.createLayer("GfxLayer") is preferred over creating layer by hand.
* @constructor
* @augments Layer
* @param {Object} props The properties to create this layer with. &lt;br />
* @param {Screen} props.screenContext The parent screen for this layer.
* @param {CanvasContextWrapper} props.canvasContextWrapper The canvasContextWrapper. This layer will draw to the canvas' context, via wrapper's exposed methods.
* @param {number} props.width The width of the layer.  Should match Screen.
* @param {number} props.height The height of the layer.  Should match Screen.
*/
function GfxLayer(props) {
  props = props || {};
  Layer.call(this, props);
  this._elements = [];
  this._dirtyElements = new UniquePriorityQueue();
  this._dirtyElements.setInvertPriority(false);
  this._removedElements = {};
  this._zIndexCounter = 0;
  // If "removeAllElements()" was called, this flag allows cleanup to do so more efficiently.
  this._allElementsRemoved = false;
};

GfxLayer.prototype = new Layer();
GfxLayer.prototype.constructor = GfxLayer;

/** Add a GfxElement to this layer.
* @param {GfxElement} element
*/
GfxLayer.prototype.addElement = function(element) {
  this._elements.push(element);

  // give a natural ordering to elements added with no specific zIndex
  // prevent render order swapping and element "switching" places
  if (element.getZIndex() === -1) {
    element.setZIndex(this._zIndexCounter++);
  }
};

/** Remove an element from the layer.
* @param {int} id The id of the element to remove
* @return {GfxElement} The removed element, if found.
*/
GfxLayer.prototype.removeElementById = function(id) {
  var idx = Utils.linSearch(this._elements, id, function(element,value){return element.getId() === value;});
  if (idx > -1) {
    return this._removeElementByIndex(idx);
  }
  return null;
};

/** Remove an element from the layer.
* @param {GfxElement} element The element to remove
* @return {GfxElement} The removed element, if found.
*/
GfxLayer.prototype.removeElement = function(element) {
  return this.removeElementById(element.getId());
};

/** Does not bounds check.
* @private
*/
GfxLayer.prototype._removeElementByIndex = function(idx) {
  this._removedElements[this._elements[idx].getId()] = this._elements[idx];
  var elem = this._elements[idx];
  // ensure it gets cleared
  elem.setDirty(true);
  elem.setHidden(true);
  this._dirtyElements.push(elem.getZIndexComparable());
  return elem;
};

/** Remove all elements from the layer.
*/
GfxLayer.prototype.removeAllElements = function() {
  for (var i = 0; i &lt; this._elements.length; i++) {
    this._removeElementByIndex(i);
  }
  this._allElementsRemoved = true;
};

/** Update the layer.
* Calls update on each element belonging to this layer.
* Checks for elements colliding with the layer boundary and emits events accordingly (event emitted from the elements themselves):
* The ELEMENT_HIT_&lt;X> events will send the following properties in the data for the events:
* &lt;ul>
* &lt;li>element : The element that hit the border&lt;/li>
* &lt;li>layer : This layer&lt;/li>
* &lt;/ul>
* @param {number} time The current time (milliseconds)
* @param {number} diff The difference between the last time and the current time  (milliseconds)
* @fires GfxLayer#ELEMENT_HIT_LEFT_EDGE
* @fires GfxLayer#ELEMENT_HIT_RIGHT_EDGE
* @fires GfxLayer#ELEMENT_HIT_TOP_EDGE
* @fires GfxLayer#ELEMENT_HIT_BOTTOM_EDGE
*/
GfxLayer.prototype.update = function(time,diff) {
  var dirtyElement;
  var i;
  for (i = 0; i &lt; this._elements.length; i++) {
      // ensure all elements are redrawn if the layer is dirty
      if (this.isDirty()) this._elements[i].setDirty(true);
      dirtyElement = this._elements[i].update(time,diff);
      if (dirtyElement) {
        this._dirtyElements.push(this._elements[i].getZIndexComparable());
      }
      this._checkBorderCollision(this._elements[i], time);
  }

  this._handleCollisions();
};

/** @private */
GfxLayer.prototype._checkBorderCollision = function(element,time) {
  if (element.getCollisionBoxX() &lt;= 0) {
    element.notify(new Event(EventType.ELEMENT_HIT_LEFT_EDGE, {layer:this, element:element}, time));
  }
  if (element.getCollisionBoxX() + element.getCollisionBoxWidth() > this.getWidth()) {
    element.notify(new Event(EventType.ELEMENT_HIT_RIGHT_EDGE, {layer:this, element:element}, time));
  }
  if (element.getCollisionBoxY() &lt;= 0) {
    element.notify(new Event(EventType.ELEMENT_HIT_TOP_EDGE, {layer:this, element:element}, time));
  }
  if (element.getCollisionBoxY() + element.getCollisionBoxHeight() > this.getHeight()) {
    element.notify(new Event(EventType.ELEMENT_HIT_BOTTOM_EDGE, {layer:this, element:element}, time));
  }
};

/** @private */
GfxLayer.prototype._handleCollisions = function() {
  var element1, element2, j;
  for (var i = 0; i &lt; this._elements.length - 1; i++) {
    element1 = this._elements[i];
    for (var j = i+1; j &lt; this._elements.length; j++) {
      element2 = this._elements[j];

      this._collisionCheckElementsIfNeeded(element1, element2);
    }
  }
};

/** @private */
GfxLayer.prototype._collisionCheckElementsIfNeeded = function(element1, element2) {
  if (element1.collidesWith(element2)) {
    this._updateElementOnCollision(element1);
    this._updateElementOnCollision(element2);
  }
};

/** @private */
GfxLayer.prototype._updateElementOnCollision = function(element) {
  element.setHasCollision(true);
  element.setDirty(true);
  this._dirtyElements.push(element.getZIndexComparable());
};

/** Execute prerendering activities.
* @override
* @param {number} time The current time (milliseconds)
* @param {number} diff The difference between the last time and the current time  (milliseconds)
*/
GfxLayer.prototype.preRender = function(time,diff) {
  var i;
  Layer.prototype.preRender.call(this,time,diff);
  // layer will have been completely cleared if dirty, so no need to clear individual elements
  if (!this.isDirty()) {
    for (i = 0; i &lt; this._dirtyElements.size(); i++) {
      this._dirtyElements.getByIndex(i).getElement().clear(this.getCanvasContextWrapper(), time,diff);
    }
  }
};

/** Render the dirty elements on this layer.
* Calls clear for all dirty elements first, then calls render on each.
* Time and diff parameters are not directly used, they are made available for extension purposes, and passed on to clear and render for the same.
* @param {number} time The current time (milliseconds)
* @param {number} diff The difference between the last time and the current time  (milliseconds)
*/
GfxLayer.prototype.render = function(time,diff) {
  while (this._dirtyElements.peek()) {
    var element = this._dirtyElements.pop().getElement();
    var doRender = element.preRender(time,diff);
    if (doRender) element.render(this.getCanvasContextWrapper(), time,diff);
    element.postRender(time,diff);
  }

  this._cleanUp();
};

/** @private */
GfxLayer.prototype._cleanUp = function() {
  if (this._allElementsRemoved) {
    this._elements = [];
    this._allElementsRemoved = false;
  } else {
    Object.keys(this._removedElements).forEach(function(elementId) {
      elementId = parseInt(elementId);
      var idx = Utils.linSearch(this._elements, elementId, function(element,value){return element.getId() === value;});
      this._elements.splice(idx,1);
    }.bind(this));
  }

  this._removedElements = {};
  this._dirtyElements.clear();
};

/** Propagate a mouse event to each of this layers elements.
* @param {Event} event
*/
GfxLayer.prototype.handleMouseEvent = function(event) {
  for (var i = 0; i &lt; this._elements.length; i++) {
    this._elements[i].handleMouseEvent(event);
  }
};

module.exports = GfxLayer;



/** An Element hit the left edge of a layer.
* @event GfxLayer#ELEMENT_HIT_LEFT_EDGE
* @type {ElementCollidesWithEdgeEvent}
*/

/** An Element hit the right edge of a layer.
* @event GfxLayer#ELEMENT_HIT_RIGHT_EDGE
* @type {ElementCollidesWithEdgeEvent}
*/

/** An Element hit the top edge of a layer.
* @event GfxLayer#ELEMENT_HIT_TOP_EDGE
* @type {ElementCollidesWithEdgeEvent}
*/

/** An Element hit the bottom edge of a layer.
* @event GfxLayer#ELEMENT_HIT_BOTTOM_EDGE
* @type {ElementCollidesWithEdgeEvent}
*/
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="EventType.html">EventType</a></li></ul><h3>Classes</h3><ul><li><a href="BackgroundLayer.html">BackgroundLayer</a></li><li><a href="CanvasContextWrapper.html">CanvasContextWrapper</a></li><li><a href="GfxElement.html">GfxElement</a></li><li><a href="GfxElementZIndexComparable.html">GfxElementZIndexComparable</a></li><li><a href="GfxLayer.html">GfxLayer</a></li><li><a href="ImageElement.html">ImageElement</a></li><li><a href="ImageLoader.html">ImageLoader</a></li><li><a href="ImageRenderer.html">ImageRenderer</a></li><li><a href="ImageSprite.html">ImageSprite</a></li><li><a href="ImageSpriteFrame.html">ImageSpriteFrame</a></li><li><a href="Layer.html">Layer</a></li><li><a href="LayerFactory.html">LayerFactory</a></li><li><a href="MouseEvent.html">MouseEvent</a></li><li><a href="MoveOrder.html">MoveOrder</a></li><li><a href="Screen.html">Screen</a></li><li><a href="Sprite.html">Sprite</a></li></ul><h3>Interfaces</h3><ul><li><a href="AnimationFrame.html">AnimationFrame</a></li><li><a href="ILayerFactory.html">ILayerFactory</a></li></ul><h3>Events</h3><ul><li><a href="BackgroundLayer.html#event:ELEMENT_HIT_BOTTOM_EDGE">ELEMENT_HIT_BOTTOM_EDGE</a></li><li><a href="BackgroundLayer.html#event:ELEMENT_HIT_LEFT_EDGE">ELEMENT_HIT_LEFT_EDGE</a></li><li><a href="BackgroundLayer.html#event:ELEMENT_HIT_RIGHT_EDGE">ELEMENT_HIT_RIGHT_EDGE</a></li><li><a href="BackgroundLayer.html#event:ELEMENT_HIT_TOP_EDGE">ELEMENT_HIT_TOP_EDGE</a></li><li><a href="GfxElement.html#event:ELEMENT_COLLISION">ELEMENT_COLLISION</a></li><li><a href="GfxElement.html#event:ELEMENT_MOVED">ELEMENT_MOVED</a></li><li><a href="GfxElement.html#event:ELEMENT_STARTED_MOVING">ELEMENT_STARTED_MOVING</a></li><li><a href="GfxElement.html#event:ELEMENT_STOPPED_MOVING">ELEMENT_STOPPED_MOVING</a></li><li><a href="GfxElement.html#event:MOUSE_DOWN_ON_ELEMENT">MOUSE_DOWN_ON_ELEMENT</a></li><li><a href="GfxElement.html#event:MOUSE_ENTER_ELEMENT">MOUSE_ENTER_ELEMENT</a></li><li><a href="GfxElement.html#event:MOUSE_EXIT_ELEMENT">MOUSE_EXIT_ELEMENT</a></li><li><a href="GfxElement.html#event:MOUSE_MOVE_OVER_ELEMENT">MOUSE_MOVE_OVER_ELEMENT</a></li><li><a href="GfxElement.html#event:MOUSE_UP_ON_ELEMENT">MOUSE_UP_ON_ELEMENT</a></li><li><a href="GfxLayer.html#event:ELEMENT_HIT_BOTTOM_EDGE">ELEMENT_HIT_BOTTOM_EDGE</a></li><li><a href="GfxLayer.html#event:ELEMENT_HIT_LEFT_EDGE">ELEMENT_HIT_LEFT_EDGE</a></li><li><a href="GfxLayer.html#event:ELEMENT_HIT_RIGHT_EDGE">ELEMENT_HIT_RIGHT_EDGE</a></li><li><a href="GfxLayer.html#event:ELEMENT_HIT_TOP_EDGE">ELEMENT_HIT_TOP_EDGE</a></li><li><a href="ImageElement.html#event:ELEMENT_COLLISION">ELEMENT_COLLISION</a></li><li><a href="ImageElement.html#event:ELEMENT_MOVED">ELEMENT_MOVED</a></li><li><a href="ImageElement.html#event:ELEMENT_STARTED_MOVING">ELEMENT_STARTED_MOVING</a></li><li><a href="ImageElement.html#event:ELEMENT_STOPPED_MOVING">ELEMENT_STOPPED_MOVING</a></li><li><a href="ImageElement.html#event:MOUSE_DOWN_ON_ELEMENT">MOUSE_DOWN_ON_ELEMENT</a></li><li><a href="ImageElement.html#event:MOUSE_ENTER_ELEMENT">MOUSE_ENTER_ELEMENT</a></li><li><a href="ImageElement.html#event:MOUSE_EXIT_ELEMENT">MOUSE_EXIT_ELEMENT</a></li><li><a href="ImageElement.html#event:MOUSE_MOVE_OVER_ELEMENT">MOUSE_MOVE_OVER_ELEMENT</a></li><li><a href="ImageElement.html#event:MOUSE_UP_ON_ELEMENT">MOUSE_UP_ON_ELEMENT</a></li><li><a href="ImageSprite.html#event:ELEMENT_COLLISION">ELEMENT_COLLISION</a></li><li><a href="ImageSprite.html#event:ELEMENT_MOVED">ELEMENT_MOVED</a></li><li><a href="ImageSprite.html#event:ELEMENT_STARTED_MOVING">ELEMENT_STARTED_MOVING</a></li><li><a href="ImageSprite.html#event:ELEMENT_STOPPED_MOVING">ELEMENT_STOPPED_MOVING</a></li><li><a href="ImageSprite.html#event:MOUSE_DOWN_ON_ELEMENT">MOUSE_DOWN_ON_ELEMENT</a></li><li><a href="ImageSprite.html#event:MOUSE_ENTER_ELEMENT">MOUSE_ENTER_ELEMENT</a></li><li><a href="ImageSprite.html#event:MOUSE_EXIT_ELEMENT">MOUSE_EXIT_ELEMENT</a></li><li><a href="ImageSprite.html#event:MOUSE_MOVE_OVER_ELEMENT">MOUSE_MOVE_OVER_ELEMENT</a></li><li><a href="ImageSprite.html#event:MOUSE_UP_ON_ELEMENT">MOUSE_UP_ON_ELEMENT</a></li><li><a href="ImageSprite.html#event:SPRITE_ANIMATION_DONE">SPRITE_ANIMATION_DONE</a></li><li><a href="Screen.html#event:AFTER_RENDER">AFTER_RENDER</a></li><li><a href="Screen.html#event:BEFORE_RENDER">BEFORE_RENDER</a></li><li><a href="Screen.html#event:MOUSE_DOWN">MOUSE_DOWN</a></li><li><a href="Screen.html#event:MOUSE_MOVE">MOUSE_MOVE</a></li><li><a href="Screen.html#event:MOUSE_UP">MOUSE_UP</a></li><li><a href="Screen.html#event:NEXT_FRAME_BEGIN">NEXT_FRAME_BEGIN</a></li><li><a href="Screen.html#event:NEXT_FRAME_END">NEXT_FRAME_END</a></li><li><a href="Screen.html#event:SCREEN_PAUSED">SCREEN_PAUSED</a></li><li><a href="Screen.html#event:SCREEN_RESUMED">SCREEN_RESUMED</a></li><li><a href="Sprite.html#event:ELEMENT_COLLISION">ELEMENT_COLLISION</a></li><li><a href="Sprite.html#event:ELEMENT_MOVED">ELEMENT_MOVED</a></li><li><a href="Sprite.html#event:ELEMENT_STARTED_MOVING">ELEMENT_STARTED_MOVING</a></li><li><a href="Sprite.html#event:ELEMENT_STOPPED_MOVING">ELEMENT_STOPPED_MOVING</a></li><li><a href="Sprite.html#event:MOUSE_DOWN_ON_ELEMENT">MOUSE_DOWN_ON_ELEMENT</a></li><li><a href="Sprite.html#event:MOUSE_ENTER_ELEMENT">MOUSE_ENTER_ELEMENT</a></li><li><a href="Sprite.html#event:MOUSE_EXIT_ELEMENT">MOUSE_EXIT_ELEMENT</a></li><li><a href="Sprite.html#event:MOUSE_MOVE_OVER_ELEMENT">MOUSE_MOVE_OVER_ELEMENT</a></li><li><a href="Sprite.html#event:MOUSE_UP_ON_ELEMENT">MOUSE_UP_ON_ELEMENT</a></li><li><a href="Sprite.html#event:SPRITE_ANIMATION_DONE">SPRITE_ANIMATION_DONE</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Sun Apr 19 2020 16:15:56 GMT-0500 (Central Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
